{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FREE PLATFORM TO LEARN CODE About the courses We offer step by step documentation for most popular programming languages. All level learners can utilize this documentation irrespective of your background technology or experience. Its well suited for beginner level developers who want to learn popular programs from scratch Learn Python This course covers python concepts from scratch and make you fully understand how python works. Click here to start learning python programming language.","title":"Home"},{"location":"#free-platform-to-learn-code","text":"","title":"FREE PLATFORM TO LEARN CODE"},{"location":"#about-the-courses","text":"We offer step by step documentation for most popular programming languages. All level learners can utilize this documentation irrespective of your background technology or experience. Its well suited for beginner level developers who want to learn popular programs from scratch","title":"About the courses"},{"location":"#learn-python","text":"This course covers python concepts from scratch and make you fully understand how python works. Click here to start learning python programming language.","title":"Learn Python"},{"location":"about/","text":"About Us What is Rathna Schools? We create simplified and interactive learning experiences. Learning programming languages should be easy to understand and available for everyone, everywhere! Easy Learning Rathna schools has focus on simplicity. Rathna schools uses simple code examples and simple illustrations of how to use it. Rathna schools' tutorials start from basic level and move all the way up to professional references. Try It Yourself Rathna schools presents lot of code examples which helps to understand the concept easier Rathna school is free Rathna school is, and will always be, a completely free developers resource.","title":"About us"},{"location":"about/#about-us","text":"","title":"About Us"},{"location":"about/#what-is-rathna-schools","text":"We create simplified and interactive learning experiences. Learning programming languages should be easy to understand and available for everyone, everywhere!","title":"What is Rathna Schools?"},{"location":"about/#easy-learning","text":"Rathna schools has focus on simplicity. Rathna schools uses simple code examples and simple illustrations of how to use it. Rathna schools' tutorials start from basic level and move all the way up to professional references.","title":"Easy Learning"},{"location":"about/#try-it-yourself","text":"Rathna schools presents lot of code examples which helps to understand the concept easier","title":"Try It Yourself"},{"location":"about/#rathna-school-is-free","text":"Rathna school is, and will always be, a completely free developers resource.","title":"Rathna school is free"},{"location":"policy/","text":"Privacy Policy for rathnaschools.com At rathnaschools, accessible from www.rathnaschools.com , one of our main priorities is the privacy of our visitors. This Privacy Policy document contains types of information that is collected and recorded by rathnaschools and how we use it. If you have additional questions or require more information about our Privacy Policy, do not hesitate to contact us. This Privacy Policy applies only to our online activities and is valid for visitors to our website with regards to the information that they shared and/or collect in rathnaschools. This policy is not applicable to any information collected offline or via channels other than this website. Consent By using our website, you hereby consent to our Privacy Policy and agree to its terms. Information we collect The personal information that you are asked to provide, and the reasons why you are asked to provide it, will be made clear to you at the point we ask you to provide your personal information. If you contact us directly, we may receive additional information about you such as your name, email address, phone number, the contents of the message and/or attachments you may send us, and any other information you may choose to provide. When you register for an Account, we may ask for your contact information, including items such as name, company name, address, email address, and telephone number. How we use your information We use the information we collect in various ways, including to: Provide, operate, and maintain our website Improve, personalize, and expand our website Understand and analyze how you use our website Develop new products, services, features, and functionality Communicate with you, either directly or through one of our partners, including for customer service, to provide you with updates and other information relating to the website, and for marketing and promotional purposes Send you emails Find and prevent fraud Log Files rathnaschools follows a standard procedure of using log files. These files log visitors when they visit websites. All hosting companies do this and a part of hosting services' analytics. The information collected by log files include internet protocol (IP) addresses, browser type, Internet Service Provider (ISP), date and time stamp, referring/exit pages, and possibly the number of clicks. These are not linked to any information that is personally identifiable. The purpose of the information is for analyzing trends, administering the site, tracking users' movement on the website, and gathering demographic information. Google DoubleClick DART Cookie Google is one of a third-party vendor on our site. It also uses cookies, known as DART cookies, to serve ads to our site visitors based upon their visit to www.website.com and other sites on the internet. However, visitors may choose to decline the use of DART cookies by visiting the Google ad and content network Privacy Policy at the following URL \u2013 https://policies.google.com/technologies/ads Advertising Partners Privacy Policies You may consult this list to find the Privacy Policy for each of the advertising partners of rathnaschools. Third-party ad servers or ad networks uses technologies like cookies, JavaScript, or Web Beacons that are used in their respective advertisements and links that appear on rathnaschools, which are sent directly to users' browser. They automatically receive your IP address when this occurs. These technologies are used to measure the effectiveness of their advertising campaigns and/or to personalize the advertising content that you see on websites that you visit. Note that rathnaschools has no access to or control over these cookies that are used by third-party advertisers. Third Party Privacy Policies rathnaschools's Privacy Policy does not apply to other advertisers or websites. Thus, we are advising you to consult the respective Privacy Policies of these third-party ad servers for more detailed information. It may include their practices and instructions about how to opt-out of certain options. You can choose to disable cookies through your individual browser options. To know more detailed information about cookie management with specific web browsers, it can be found at the browsers' respective websites. CCPA Privacy Rights (Do Not Sell My Personal Information) Under the CCPA, among other rights, California consumers have the right to: Request that a business that collects a consumer's personal data disclose the categories and specific pieces of personal data that a business has collected about consumers. Request that a business delete any personal data about the consumer that a business has collected. Request that a business that sells a consumer's personal data, not sell the consumer's personal data. If you make a request, we have one month to respond to you. If you would like to exercise any of these rights, please contact us. GDPR Data Protection Rights We would like to make sure you are fully aware of all of your data protection rights. Every user is entitled to the following: The right to access \u2013 You have the right to request copies of your personal data. We may charge you a small fee for this service. The right to rectification \u2013 You have the right to request that we correct any information you believe is inaccurate. You also have the right to request that we complete the information you believe is incomplete. The right to erasure \u2013 You have the right to request that we erase your personal data, under certain conditions. The right to restrict processing \u2013 You have the right to request that we restrict the processing of your personal data, under certain conditions. The right to object to processing \u2013 You have the right to object to our processing of your personal data, under certain conditions. The right to data portability \u2013 You have the right to request that we transfer the data that we have collected to another organization, or directly to you, under certain conditions. If you make a request, we have one month to respond to yo u. If you would like to exercise any of these rights, please contact us. Children's Information Another part of our priority is adding protection for children while using the internet. We encourage parents and guardians to observe, participate in, and/or monitor and guide their online activity. rathnaschools does not knowingly collect any Personal Identifiable Information from children under the age of 13. If you think that your child provided this kind of information on our website, we strongly encourage you to contact us immediately by e\u2011mail at Rathinavelkumar.Murugan@gmail.com and we will do our best efforts to promptly remove such information from our records.","title":"Privacy policy"},{"location":"policy/#privacy-policy-for-rathnaschoolscom","text":"At rathnaschools, accessible from www.rathnaschools.com , one of our main priorities is the privacy of our visitors. This Privacy Policy document contains types of information that is collected and recorded by rathnaschools and how we use it. If you have additional questions or require more information about our Privacy Policy, do not hesitate to contact us. This Privacy Policy applies only to our online activities and is valid for visitors to our website with regards to the information that they shared and/or collect in rathnaschools. This policy is not applicable to any information collected offline or via channels other than this website.","title":"Privacy Policy for rathnaschools.com"},{"location":"policy/#consent","text":"By using our website, you hereby consent to our Privacy Policy and agree to its terms.","title":"Consent"},{"location":"policy/#information-we-collect","text":"The personal information that you are asked to provide, and the reasons why you are asked to provide it, will be made clear to you at the point we ask you to provide your personal information. If you contact us directly, we may receive additional information about you such as your name, email address, phone number, the contents of the message and/or attachments you may send us, and any other information you may choose to provide. When you register for an Account, we may ask for your contact information, including items such as name, company name, address, email address, and telephone number.","title":"Information we collect"},{"location":"policy/#how-we-use-your-information","text":"We use the information we collect in various ways, including to: Provide, operate, and maintain our website Improve, personalize, and expand our website Understand and analyze how you use our website Develop new products, services, features, and functionality Communicate with you, either directly or through one of our partners, including for customer service, to provide you with updates and other information relating to the website, and for marketing and promotional purposes Send you emails Find and prevent fraud","title":"How we use your information"},{"location":"policy/#log-files","text":"rathnaschools follows a standard procedure of using log files. These files log visitors when they visit websites. All hosting companies do this and a part of hosting services' analytics. The information collected by log files include internet protocol (IP) addresses, browser type, Internet Service Provider (ISP), date and time stamp, referring/exit pages, and possibly the number of clicks. These are not linked to any information that is personally identifiable. The purpose of the information is for analyzing trends, administering the site, tracking users' movement on the website, and gathering demographic information.","title":"Log Files"},{"location":"policy/#google-doubleclick-dart-cookie","text":"Google is one of a third-party vendor on our site. It also uses cookies, known as DART cookies, to serve ads to our site visitors based upon their visit to www.website.com and other sites on the internet. However, visitors may choose to decline the use of DART cookies by visiting the Google ad and content network Privacy Policy at the following URL \u2013 https://policies.google.com/technologies/ads","title":"Google DoubleClick DART Cookie"},{"location":"policy/#advertising-partners-privacy-policies","text":"You may consult this list to find the Privacy Policy for each of the advertising partners of rathnaschools. Third-party ad servers or ad networks uses technologies like cookies, JavaScript, or Web Beacons that are used in their respective advertisements and links that appear on rathnaschools, which are sent directly to users' browser. They automatically receive your IP address when this occurs. These technologies are used to measure the effectiveness of their advertising campaigns and/or to personalize the advertising content that you see on websites that you visit. Note that rathnaschools has no access to or control over these cookies that are used by third-party advertisers.","title":"Advertising Partners Privacy Policies"},{"location":"policy/#third-party-privacy-policies","text":"rathnaschools's Privacy Policy does not apply to other advertisers or websites. Thus, we are advising you to consult the respective Privacy Policies of these third-party ad servers for more detailed information. It may include their practices and instructions about how to opt-out of certain options. You can choose to disable cookies through your individual browser options. To know more detailed information about cookie management with specific web browsers, it can be found at the browsers' respective websites.","title":"Third Party Privacy Policies"},{"location":"policy/#ccpa-privacy-rights-do-not-sell-my-personal-information","text":"Under the CCPA, among other rights, California consumers have the right to: Request that a business that collects a consumer's personal data disclose the categories and specific pieces of personal data that a business has collected about consumers. Request that a business delete any personal data about the consumer that a business has collected. Request that a business that sells a consumer's personal data, not sell the consumer's personal data. If you make a request, we have one month to respond to you. If you would like to exercise any of these rights, please contact us.","title":"CCPA Privacy Rights (Do Not Sell My Personal Information)"},{"location":"policy/#gdpr-data-protection-rights","text":"We would like to make sure you are fully aware of all of your data protection rights. Every user is entitled to the following: The right to access \u2013 You have the right to request copies of your personal data. We may charge you a small fee for this service. The right to rectification \u2013 You have the right to request that we correct any information you believe is inaccurate. You also have the right to request that we complete the information you believe is incomplete. The right to erasure \u2013 You have the right to request that we erase your personal data, under certain conditions. The right to restrict processing \u2013 You have the right to request that we restrict the processing of your personal data, under certain conditions. The right to object to processing \u2013 You have the right to object to our processing of your personal data, under certain conditions. The right to data portability \u2013 You have the right to request that we transfer the data that we have collected to another organization, or directly to you, under certain conditions. If you make a request, we have one month to respond to yo u. If you would like to exercise any of these rights, please contact us.","title":"GDPR Data Protection Rights"},{"location":"policy/#childrens-information","text":"Another part of our priority is adding protection for children while using the internet. We encourage parents and guardians to observe, participate in, and/or monitor and guide their online activity. rathnaschools does not knowingly collect any Personal Identifiable Information from children under the age of 13. If you think that your child provided this kind of information on our website, we strongly encourage you to contact us immediately by e\u2011mail at Rathinavelkumar.Murugan@gmail.com and we will do our best efforts to promptly remove such information from our records.","title":"Children's Information"},{"location":"terms/","text":"Website Terms and Conditions of Use 1. Terms By accessing this Website, accessible from RATHNA SCHOOLS , you are agreeing to be bound by these Website Terms and Conditions of Use and agree that you are responsible for the agreement with any applicable local laws. If you disagree with any of these terms, you are prohibited from accessing this site. The materials contained in this Website are protected by copyright and trade mark law. 2. Use License Permission is granted to temporarily download one copy of the materials on rathnaschools.com's Website for personal, non-commercial transitory viewing only. This is the grant of a license, not a transfer of title, and under this license you may not: modify or copy the materials; use the materials for any commercial purpose or for any public display; attempt to reverse engineer any software contained on rathnaschools.com's Website; remove any copyright or other proprietary notations from the materials; or transferring the materials to another person or \"mirror\" the materials on any other server. This will let rathnaschools.com to terminate upon violations of any of these restrictions. Upon termination, your viewing right will also be terminated and you should destroy any downloaded materials in your possession whether it is printed or electronic format. 3. Disclaimer All the materials on rathnaschools.com\u2019s Website are provided \"as is\". rathnaschools.com makes no warranties, may it be expressed or implied, therefore negates all other warranties. Furthermore, rathnaschools.com does not make any representations concerning the accuracy or reliability of the use of the materials on its Website or otherwise relating to such materials or any sites linked to this Website. 4. Limitations rathnaschools.com or its suppliers will not be hold accountable for any damages that will arise with the use or inability to use the materials on rathnaschools.com\u2019s Website, even if rathnaschools.com or an authorize representative of this Website has been notified, orally or written, of the possibility of such damage. Some jurisdiction does not allow limitations on implied warranties or limitations of liability for incidental damages, these limitations may not apply to you. 5. Revisions and Errata The materials appearing on rathnaschools.com\u2019s Website may include technical, typographical, or photographic errors. rathnaschools.com will not promise that any of the materials in this Website are accurate, complete, or current. rathnaschools.com may change the materials contained on its Website at any time without notice. rathnaschools.com does not make any commitment to update the materials. 6. Links rathnaschools.com has not reviewed all of the sites linked to its Website and is not responsible for the contents of any such linked site. The presence of any link does not imply endorsement by rathnaschools.com of the site. The use of any linked website is at the user\u2019s own risk. 7. Site Terms of Use Modifications rathnaschools.com may revise these Terms of Use for its Website at any time without prior notice. By using this Website, you are agreeing to be bound by the current version of these Terms and Conditions of Use. 8. Your Privacy Please read our Privacy Policy. 9. Governing Law Any claim related to rathnaschools.com's Website shall be governed by the laws of in without regards to its conflict of law provisions.","title":"Terms of use"},{"location":"terms/#website-terms-and-conditions-of-use","text":"","title":"Website Terms and Conditions of Use"},{"location":"terms/#1-terms","text":"By accessing this Website, accessible from RATHNA SCHOOLS , you are agreeing to be bound by these Website Terms and Conditions of Use and agree that you are responsible for the agreement with any applicable local laws. If you disagree with any of these terms, you are prohibited from accessing this site. The materials contained in this Website are protected by copyright and trade mark law.","title":"1. Terms"},{"location":"terms/#2-use-license","text":"Permission is granted to temporarily download one copy of the materials on rathnaschools.com's Website for personal, non-commercial transitory viewing only. This is the grant of a license, not a transfer of title, and under this license you may not: modify or copy the materials; use the materials for any commercial purpose or for any public display; attempt to reverse engineer any software contained on rathnaschools.com's Website; remove any copyright or other proprietary notations from the materials; or transferring the materials to another person or \"mirror\" the materials on any other server. This will let rathnaschools.com to terminate upon violations of any of these restrictions. Upon termination, your viewing right will also be terminated and you should destroy any downloaded materials in your possession whether it is printed or electronic format.","title":"2. Use License"},{"location":"terms/#3-disclaimer","text":"All the materials on rathnaschools.com\u2019s Website are provided \"as is\". rathnaschools.com makes no warranties, may it be expressed or implied, therefore negates all other warranties. Furthermore, rathnaschools.com does not make any representations concerning the accuracy or reliability of the use of the materials on its Website or otherwise relating to such materials or any sites linked to this Website.","title":"3. Disclaimer"},{"location":"terms/#4-limitations","text":"rathnaschools.com or its suppliers will not be hold accountable for any damages that will arise with the use or inability to use the materials on rathnaschools.com\u2019s Website, even if rathnaschools.com or an authorize representative of this Website has been notified, orally or written, of the possibility of such damage. Some jurisdiction does not allow limitations on implied warranties or limitations of liability for incidental damages, these limitations may not apply to you.","title":"4. Limitations"},{"location":"terms/#5-revisions-and-errata","text":"The materials appearing on rathnaschools.com\u2019s Website may include technical, typographical, or photographic errors. rathnaschools.com will not promise that any of the materials in this Website are accurate, complete, or current. rathnaschools.com may change the materials contained on its Website at any time without notice. rathnaschools.com does not make any commitment to update the materials.","title":"5. Revisions and Errata"},{"location":"terms/#6-links","text":"rathnaschools.com has not reviewed all of the sites linked to its Website and is not responsible for the contents of any such linked site. The presence of any link does not imply endorsement by rathnaschools.com of the site. The use of any linked website is at the user\u2019s own risk.","title":"6. Links"},{"location":"terms/#7-site-terms-of-use-modifications","text":"rathnaschools.com may revise these Terms of Use for its Website at any time without prior notice. By using this Website, you are agreeing to be bound by the current version of these Terms and Conditions of Use.","title":"7. Site Terms of Use Modifications"},{"location":"terms/#8-your-privacy","text":"Please read our Privacy Policy.","title":"8. Your Privacy"},{"location":"terms/#9-governing-law","text":"Any claim related to rathnaschools.com's Website shall be governed by the laws of in without regards to its conflict of law provisions.","title":"9. Governing Law"},{"location":"python/","text":"Python is a popular programming language. Its an easy to learn and powerful programing language. Its's elegant syntax and dynamic typing features, make it an ideal language for scripting and rapid application development in many areas on most platforms. History of Python Guido Van Rossum - Python was developed by Guido Van Rossum in the late 1980s and its implementation was started in December 1989 at CWI in the Netherlands Python 1.0 - Python 1.0 was released on 1994, with new features like lambda, map filter and reduce operations Python 2.0 - Python was released on 2000, with new features like garbage collector for memory management and support for unicode Python 3.0 - Python was released on 2008 after long period of testing. It was designed to rectify fundamental design flaws in the older versions Where we can use python? AI and Machine Learning - Python is a perfect language for various machine learning, deep learning and artificial intelligence projects Web Development - Python can be used to create web applications. Django, Flask and Pyramid are the very famous python web development frameworks Data analytics and Visualization - Python provides a variety of graphing libraries to collect, manipulate, organize and visualize the data. It is another popular and vast developing area of interest Embedded systems - In python, we can write code to control hardware systems and robots. MicroPython, Raspberry Pi, PythonRobotics are the most famous library for home automation, IOT and robotics Automation - Python is beginner friendly to automate any tasks on the computer. The task which we are performing over and over again, can be automate more efficiently using python Characteristics of Python Interpreted language - Before execution, we are not required to compile the python program because it is processed at runtime by the interpreter Cross-platform language - Code Once Run Anywhere - Python is a portable language which equally runs on different platforms like windows, linux, macintosh etc. Object-Oriented language - Python supports all OOPS concepts like classes, objects, inheritance, encapsulation, polymorphism etc. It helps to develop application with minimal and reusable code Free and Open-Source - Python is free and open-source which source code is available in public for download, use, modify and distribution Dynamically Typed - In Python, We don't need to declare the variable data type since interpreter automatically determine the data type ar run time based on the given expression","title":"Python Introduction"},{"location":"python/#history-of-python","text":"Guido Van Rossum - Python was developed by Guido Van Rossum in the late 1980s and its implementation was started in December 1989 at CWI in the Netherlands Python 1.0 - Python 1.0 was released on 1994, with new features like lambda, map filter and reduce operations Python 2.0 - Python was released on 2000, with new features like garbage collector for memory management and support for unicode Python 3.0 - Python was released on 2008 after long period of testing. It was designed to rectify fundamental design flaws in the older versions","title":"History of Python"},{"location":"python/#where-we-can-use-python","text":"AI and Machine Learning - Python is a perfect language for various machine learning, deep learning and artificial intelligence projects Web Development - Python can be used to create web applications. Django, Flask and Pyramid are the very famous python web development frameworks Data analytics and Visualization - Python provides a variety of graphing libraries to collect, manipulate, organize and visualize the data. It is another popular and vast developing area of interest Embedded systems - In python, we can write code to control hardware systems and robots. MicroPython, Raspberry Pi, PythonRobotics are the most famous library for home automation, IOT and robotics Automation - Python is beginner friendly to automate any tasks on the computer. The task which we are performing over and over again, can be automate more efficiently using python","title":"Where we can use python?"},{"location":"python/#characteristics-of-python","text":"Interpreted language - Before execution, we are not required to compile the python program because it is processed at runtime by the interpreter Cross-platform language - Code Once Run Anywhere - Python is a portable language which equally runs on different platforms like windows, linux, macintosh etc. Object-Oriented language - Python supports all OOPS concepts like classes, objects, inheritance, encapsulation, polymorphism etc. It helps to develop application with minimal and reusable code Free and Open-Source - Python is free and open-source which source code is available in public for download, use, modify and distribution Dynamically Typed - In Python, We don't need to declare the variable data type since interpreter automatically determine the data type ar run time based on the given expression","title":"Characteristics of Python"},{"location":"python/classes_objects/","text":"Python is a multi-paradigm programming language which means, it supports to implement both object oriented programing and procedural programming in python What is OOPs OOPS is a very famous and popular programming paradigm. It deals with the concept of classes and object where classes are consider as blueprints, based on that object can be created as individual instances. In upcoming sections, we will see the below important OOP concepts with real time programming examples Class Object Method Inheritance Encapsulation Polymorphism Data Abstraction Class, Object and Method Object is a group of variables and methods where class is the blueprint of that object REALTIME EXAMPLE: Project Name : Fruits Database ############# Class Blueprint ############### class FruitsDatabase: #Class attributes database_type = \"fruits\" #Constructor def __init__(self, name): self.name = name #Method def list_the_usage(self, benefits): for each_benefit in benefits: print(each_benefit) ############# Object Creation - 1 ############### apple_fruit = FruitsDatabase(\"APPLE\") apple_benefits = [\"Healthy Immune system\", \"Diabetes-Friendly Fruit\"] #Printing the required values print(\"####### APPLE DATA #######\") print(apple_fruit.database_type) print(apple_fruit.name) apple_fruit.list_the_usage(apple_benefits) ############# Object Creation - 2 ############### orange_fruit = FruitsDatabase(\"ORANGE\") orange_benefits = [\"Protect your cell from damage\", \"Boosts your immune system\"] #Printing the required values print(\"####### ORANGE DATA #######\") print(orange_fruit.database_type) print(orange_fruit.name) orange_fruit.list_the_usage(orange_benefits) ############# Object Creation - 3 ############### mango_fruit = FruitsDatabase(\"MANGO\") mango_benefits = [\"Improve Digestive Health\", \"High in Antioxidants\", \"Improve hair and skin health\"] #Printing the required values print(\"####### MANGO DATA #######\") print(mango_fruit.database_type) print(mango_fruit.name) mango_fruit.list_the_usage(mango_benefits) Output ####### APPLE DATA ####### fruits APPLE Healthy Immune system Diabetes-Friendly Fruit ####### ORANGE DATA ####### fruits ORANGE Protect your cell from damage Boosts your immune system ####### MANGO DATA ####### fruits MANGO Improve Digestive Health High in Antioxidants Improve hair and skin health","title":"Python Classes & Objects"},{"location":"python/classes_objects/#what-is-oops","text":"OOPS is a very famous and popular programming paradigm. It deals with the concept of classes and object where classes are consider as blueprints, based on that object can be created as individual instances. In upcoming sections, we will see the below important OOP concepts with real time programming examples Class Object Method Inheritance Encapsulation Polymorphism Data Abstraction","title":"What is OOPs"},{"location":"python/classes_objects/#class-object-and-method","text":"Object is a group of variables and methods where class is the blueprint of that object REALTIME EXAMPLE: Project Name : Fruits Database ############# Class Blueprint ############### class FruitsDatabase: #Class attributes database_type = \"fruits\" #Constructor def __init__(self, name): self.name = name #Method def list_the_usage(self, benefits): for each_benefit in benefits: print(each_benefit) ############# Object Creation - 1 ############### apple_fruit = FruitsDatabase(\"APPLE\") apple_benefits = [\"Healthy Immune system\", \"Diabetes-Friendly Fruit\"] #Printing the required values print(\"####### APPLE DATA #######\") print(apple_fruit.database_type) print(apple_fruit.name) apple_fruit.list_the_usage(apple_benefits) ############# Object Creation - 2 ############### orange_fruit = FruitsDatabase(\"ORANGE\") orange_benefits = [\"Protect your cell from damage\", \"Boosts your immune system\"] #Printing the required values print(\"####### ORANGE DATA #######\") print(orange_fruit.database_type) print(orange_fruit.name) orange_fruit.list_the_usage(orange_benefits) ############# Object Creation - 3 ############### mango_fruit = FruitsDatabase(\"MANGO\") mango_benefits = [\"Improve Digestive Health\", \"High in Antioxidants\", \"Improve hair and skin health\"] #Printing the required values print(\"####### MANGO DATA #######\") print(mango_fruit.database_type) print(mango_fruit.name) mango_fruit.list_the_usage(mango_benefits) Output ####### APPLE DATA ####### fruits APPLE Healthy Immune system Diabetes-Friendly Fruit ####### ORANGE DATA ####### fruits ORANGE Protect your cell from damage Boosts your immune system ####### MANGO DATA ####### fruits MANGO Improve Digestive Health High in Antioxidants Improve hair and skin health","title":"Class, Object and Method"},{"location":"python/conditional_statement/","text":"Conditional statement are used to check for the condition and based on the result, it will execute the statement If Statement Check the condition, if its true then execute the statement which is available inside the block #IF statement age = 25 #Check the age is greater tha 18 if age>18: print(\"Eligible to Vote\") Output Eligible to Vote If - Else Statement Check the condition, if its true then execute the statement which is available inside the if block, if its false then execute the statement which is available inside the else block #IF - ELSE statement age = 14 #Check the age is greater tha 18 if age>18: print(\"Eligible to Vote\") else: print(\"InEligible to Vote\") Output InEligible to Vote If - Elif - Else Statement With the help of elif keyword, we can check the multiple else condition in python #IF - ELIF - ELSE statement mark = 75 #Checking the mark with different grade levels if mark>90: print(\"A Grade\") elif mark>80: print(\"B Grade\") elif mark>70: print(\"C Grade\") elif mark>60: print(\"D Grade\") elif mark>50: print(\"E Grade\") else: print(\"F Grade\") Output C Grade Nested If Else Statements Inside the conditional statements, we can nest multiple if and else condition like the below example #Nested IF-ELSE statements mark = 75 #Checking the mark with different grade levels if mark>50: if mark>60: if mark>70: if mark>80: if mark>90: print(\"A Grade\") else: print(\"B Grade\") else: print(\"C Grade\") else: print(\"D Grade\") else: print(\"E Grade\") else: print(\"F Grade\") Output C Grade Shorthand If Statement If we have only one line inside if block, then we can use shorthand method like below to reduce the coding lines #Shorthand IF statement age = 25 #Check the age is greater tha 18 if age>18: print(\"Eligible to Vote\") Output Eligible to Vote Shorthand Else Statement If we have only one line inside if and else block, then we can use shorthand method like below to reduce the coding lines #Shorthand IF-ELSE statement age = 14 #Check the age is greater than 18 print(\"Eligible to Vote\") if age>18 else print(\"InEligible\") Output InEligible Pass Statement Sometimes for future implementation, we required the placeholders, Pass statement helps to achieve this, it ignores by interpreter and won't throws any error #Pass statement age = 14 #Interpreter ignores pass statement if age>18: pass print(\"Age is : {}\".format(age)) Output Age is : 14","title":"Conditional Statement"},{"location":"python/conditional_statement/#if-statement","text":"Check the condition, if its true then execute the statement which is available inside the block #IF statement age = 25 #Check the age is greater tha 18 if age>18: print(\"Eligible to Vote\") Output Eligible to Vote","title":"If Statement"},{"location":"python/conditional_statement/#if-else-statement","text":"Check the condition, if its true then execute the statement which is available inside the if block, if its false then execute the statement which is available inside the else block #IF - ELSE statement age = 14 #Check the age is greater tha 18 if age>18: print(\"Eligible to Vote\") else: print(\"InEligible to Vote\") Output InEligible to Vote","title":"If - Else Statement"},{"location":"python/conditional_statement/#if-elif-else-statement","text":"With the help of elif keyword, we can check the multiple else condition in python #IF - ELIF - ELSE statement mark = 75 #Checking the mark with different grade levels if mark>90: print(\"A Grade\") elif mark>80: print(\"B Grade\") elif mark>70: print(\"C Grade\") elif mark>60: print(\"D Grade\") elif mark>50: print(\"E Grade\") else: print(\"F Grade\") Output C Grade","title":"If - Elif - Else Statement"},{"location":"python/conditional_statement/#nested-if-else-statements","text":"Inside the conditional statements, we can nest multiple if and else condition like the below example #Nested IF-ELSE statements mark = 75 #Checking the mark with different grade levels if mark>50: if mark>60: if mark>70: if mark>80: if mark>90: print(\"A Grade\") else: print(\"B Grade\") else: print(\"C Grade\") else: print(\"D Grade\") else: print(\"E Grade\") else: print(\"F Grade\") Output C Grade","title":"Nested If Else Statements"},{"location":"python/conditional_statement/#shorthand-if-statement","text":"If we have only one line inside if block, then we can use shorthand method like below to reduce the coding lines #Shorthand IF statement age = 25 #Check the age is greater tha 18 if age>18: print(\"Eligible to Vote\") Output Eligible to Vote","title":"Shorthand If Statement"},{"location":"python/conditional_statement/#shorthand-else-statement","text":"If we have only one line inside if and else block, then we can use shorthand method like below to reduce the coding lines #Shorthand IF-ELSE statement age = 14 #Check the age is greater than 18 print(\"Eligible to Vote\") if age>18 else print(\"InEligible\") Output InEligible","title":"Shorthand Else Statement"},{"location":"python/conditional_statement/#pass-statement","text":"Sometimes for future implementation, we required the placeholders, Pass statement helps to achieve this, it ignores by interpreter and won't throws any error #Pass statement age = 14 #Interpreter ignores pass statement if age>18: pass print(\"Age is : {}\".format(age)) Output Age is : 14","title":"Pass Statement"},{"location":"python/dict_functions/","text":"Various built-in functions are available in Python which helps to perform multiple operations on dictionary. Below are the top must know dict methods in python Length Function This function helps to return the length of the given dictionary data items #Length Function language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", 4 : \"C++\" } print(\"The length of the given dict datasets is : \") print(len(language_dict)) Output The length of the given dict datasets is : 4 Clear Method Clear method helps to remove all the elements in given dict data items and make it as empty dict #Clear Method language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", 4 : \"C++\" } print(\"The clear method removes all data...\") language_dict.clear() print(language_dict) Output The clear method removes all data... {} Get Method Get method helps to get the value for that specified key from given dict data items #Get Method language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", 4 : \"C++\" } print(\"The get method retrieves the key's value...\") print(language_dict.get(3)) Output The get method retrieves the key's value... JavaScript PopItem Method Popitem method helps to remove the last key value pair from dict by default #PopItem Method language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", 4 : \"C++\" } print(\"The popitem method removes the last item from dict...\") language_dict.popitem() print(language_dict) Output The popitem method removes the last item from dict... {1: 'Python', 2: 'Java', 3: 'JavaScript'} Copy Method Copy method helps to copy the given dict to another variable #Copy Method language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", 4 : \"C++\" } print(id(language_dict)) print(\"Making a copy of dict data in different memory location\") language_dict_copy = language_dict.copy() print(language_dict_copy) print(id(language_dict_copy)) Output 140312120052864 Making a copy of dict data in different memory location {1: 'Python', 2: 'Java', 3: 'JavaScript', 4: 'C++'} 140312120052928 Fromkeys Method Fromkey function helps to create dictionary from the given keys list and value #Fromkey Method language_keys = {1, 2, 3, 4} language_values = \"Python\" print(\"Creation of a dict using the fromkey method\") language_dict = dict.fromkeys(language_keys, language_values) print(language_dict) Output Creation of a dict using the fromkey method {1: 'Python', 2: 'Python', 3: 'Python', 4: 'Python'} SetDefault Method setDefault helps to return the given key's value as default. if the key is not available none will returns #SetDefault Method language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\" } #SetDefault returns the value of the corresponding key result=language_dict.setdefault(3) print(result) #None will return if the key is not available result=language_dict.setdefault(5) print(result) #Create new pair, if we pass value also as a parameter result=language_dict.setdefault(4,\"C++\") print(language_dict) print(result) Output: JavaScript None {1: 'Python', 2: 'Java', 3: 'JavaScript', 5: None, 4: 'C++'} C++","title":"Dict Functions"},{"location":"python/dict_functions/#length-function","text":"This function helps to return the length of the given dictionary data items #Length Function language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", 4 : \"C++\" } print(\"The length of the given dict datasets is : \") print(len(language_dict)) Output The length of the given dict datasets is : 4","title":"Length Function"},{"location":"python/dict_functions/#clear-method","text":"Clear method helps to remove all the elements in given dict data items and make it as empty dict #Clear Method language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", 4 : \"C++\" } print(\"The clear method removes all data...\") language_dict.clear() print(language_dict) Output The clear method removes all data... {}","title":"Clear Method"},{"location":"python/dict_functions/#get-method","text":"Get method helps to get the value for that specified key from given dict data items #Get Method language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", 4 : \"C++\" } print(\"The get method retrieves the key's value...\") print(language_dict.get(3)) Output The get method retrieves the key's value... JavaScript","title":"Get Method"},{"location":"python/dict_functions/#popitem-method","text":"Popitem method helps to remove the last key value pair from dict by default #PopItem Method language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", 4 : \"C++\" } print(\"The popitem method removes the last item from dict...\") language_dict.popitem() print(language_dict) Output The popitem method removes the last item from dict... {1: 'Python', 2: 'Java', 3: 'JavaScript'}","title":"PopItem Method"},{"location":"python/dict_functions/#copy-method","text":"Copy method helps to copy the given dict to another variable #Copy Method language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", 4 : \"C++\" } print(id(language_dict)) print(\"Making a copy of dict data in different memory location\") language_dict_copy = language_dict.copy() print(language_dict_copy) print(id(language_dict_copy)) Output 140312120052864 Making a copy of dict data in different memory location {1: 'Python', 2: 'Java', 3: 'JavaScript', 4: 'C++'} 140312120052928","title":"Copy Method"},{"location":"python/dict_functions/#fromkeys-method","text":"Fromkey function helps to create dictionary from the given keys list and value #Fromkey Method language_keys = {1, 2, 3, 4} language_values = \"Python\" print(\"Creation of a dict using the fromkey method\") language_dict = dict.fromkeys(language_keys, language_values) print(language_dict) Output Creation of a dict using the fromkey method {1: 'Python', 2: 'Python', 3: 'Python', 4: 'Python'}","title":"Fromkeys Method"},{"location":"python/dict_functions/#setdefault-method","text":"setDefault helps to return the given key's value as default. if the key is not available none will returns #SetDefault Method language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\" } #SetDefault returns the value of the corresponding key result=language_dict.setdefault(3) print(result) #None will return if the key is not available result=language_dict.setdefault(5) print(result) #Create new pair, if we pass value also as a parameter result=language_dict.setdefault(4,\"C++\") print(language_dict) print(result) Output: JavaScript None {1: 'Python', 2: 'Java', 3: 'JavaScript', 5: None, 4: 'C++'} C++","title":"SetDefault Method"},{"location":"python/for_loop/","text":"Similar to while loop, for loops are also used to execute the same instruction again and again until the conditions get satisfied and also helps to iterating list sequence, tuple sequence etc. For Loop There are two use cases available for FOR loop statement in python First Use Case - Iterating over the sequence data types without any specific index variable #For Loop - Without Index month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"] for each_month in month_list: print(each_month) Output Jan Feb Mar Apr May Second Use Case - Iterating with specified number of times - Using Range Function #For Loop - With Index month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"] for index in range(0, len(month_list)): print(month_list[index]) Output Jan Feb Mar Apr May For Break Even though the condition is true still we can stop the loop with the help of break statement #For Break month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"] for index in range(0, len(month_list)): if month_list[index]==\"Apr\": break print(month_list[index]) Output Jan Feb Mar For Continue Even though the condition is true still we can stop the specific iteration using continue statement #For Continue month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"] for index in range(0, len(month_list)): #only skip April month if month_list[index]==\"Apr\": continue print(month_list[index]) Output Jan Feb Mar May For Else One of the unique feature in python is for loop with else clause. When the condition get false it will execute the else statement #For Else month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"] for index in range(0, len(month_list)): print(month_list[index]) else: print(\"I am else block\") Output Jan Feb Mar Apr May I am else block For Break Else When break is executed, the else wont execute in for loop #For Break Else month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"] for index in range(0, len(month_list)): print(month_list[index]) if month_list[index]==\"Mar\": break #Else block wont execute since it breaks else: print(\"I am else block\") Output Jan Feb Mar For Continue Else Else statement execute for continue since it will only skip only the particular execution #For Continue Else month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"] for index in range(0, len(month_list)): if month_list[index]==\"Mar\": continue print(month_list[index]) #Else block execute since it continues else: print(\"I am else block\") Output Jan Feb Apr May I am else block","title":"For Loop Statements"},{"location":"python/for_loop/#for-loop","text":"There are two use cases available for FOR loop statement in python First Use Case - Iterating over the sequence data types without any specific index variable #For Loop - Without Index month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"] for each_month in month_list: print(each_month) Output Jan Feb Mar Apr May Second Use Case - Iterating with specified number of times - Using Range Function #For Loop - With Index month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"] for index in range(0, len(month_list)): print(month_list[index]) Output Jan Feb Mar Apr May","title":"For Loop"},{"location":"python/for_loop/#for-break","text":"Even though the condition is true still we can stop the loop with the help of break statement #For Break month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"] for index in range(0, len(month_list)): if month_list[index]==\"Apr\": break print(month_list[index]) Output Jan Feb Mar","title":"For Break"},{"location":"python/for_loop/#for-continue","text":"Even though the condition is true still we can stop the specific iteration using continue statement #For Continue month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"] for index in range(0, len(month_list)): #only skip April month if month_list[index]==\"Apr\": continue print(month_list[index]) Output Jan Feb Mar May","title":"For Continue"},{"location":"python/for_loop/#for-else","text":"One of the unique feature in python is for loop with else clause. When the condition get false it will execute the else statement #For Else month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"] for index in range(0, len(month_list)): print(month_list[index]) else: print(\"I am else block\") Output Jan Feb Mar Apr May I am else block","title":"For Else"},{"location":"python/for_loop/#for-break-else","text":"When break is executed, the else wont execute in for loop #For Break Else month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"] for index in range(0, len(month_list)): print(month_list[index]) if month_list[index]==\"Mar\": break #Else block wont execute since it breaks else: print(\"I am else block\") Output Jan Feb Mar","title":"For Break Else"},{"location":"python/for_loop/#for-continue-else","text":"Else statement execute for continue since it will only skip only the particular execution #For Continue Else month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"] for index in range(0, len(month_list)): if month_list[index]==\"Mar\": continue print(month_list[index]) #Else block execute since it continues else: print(\"I am else block\") Output Jan Feb Apr May I am else block","title":"For Continue Else"},{"location":"python/function_arguments/","text":"In this part, we are going to deep dive about different types of arguments in functions Below are the types of arguments Default Arguments positional Arguments Keyword Arguments Arbitrary Positional Arguments Arbitrary keyword arguments Default Arguments Function Definition with default value for num2 and non-default value for num1 Default argument should be declare after the Non-default arguments #Default Arguments #num2 is default argument here def add(num1, num2=100): value1 = num1 value2 = num2 sum = value1 + value2 return sum #Function Calling result = add(10, 20) print(result) #Default argument is optional result = add(50) print(result) Output 30 150 Positional Arguments When we are calling the function, the order of passing arguments should be matched with the order of parameters in function definition #positional Arguments def add(num1, num2: value1 = num1 value2 = num2 sum = value1 + value2 return sum #Function Calling #Automatically 10 is assigns with num1 and 20 is assigns with num2 result = add(10, 20) print(result) Output 30 150 Keyword Arguments In keyword arguments, we can change the order of the arguments by explicitly mentioned the function parameter name #Keyword Arguments def add(num1, num2): value1 = num1 value2 = num2 print(\"The value of num1 is : {}\".format(num1)) print(\"The value of num2 is : {}\".format(num2)) sum = value1 + value2 return sum #Function Calling with keyword arguments result = add(num2=10, num1=20) print(result) Output The value of num1 is : 20 The value of num2 is : 10 30 Arbitrary Positional Arguments When we are unsure on the number of parameters should be declare during function definition, asterisk (*) can place to get the dynamic positional arguments #Arbitrary Positional Arguments def add(*args): sum=0 for each in args: sum = sum + each return sum #Function Calling with Arbitrary Positional Arguments result = add(10, 20, 30) print(result) Output 60 Arbitrary Keyword Arguments Double asterisk (**) can place to get the dynamic keyword arguments #Arbitrary Keyword Arguments def add(**args): sum=0 for key, value in args.items(): print(key, value) sum = sum + value return sum #Function Calling with Arbitrary Keyword Arguments result = add(num1=10, num2=20, num3=30) print(result) Output num1 10 num2 20 num3 30 60","title":"Function Arguments"},{"location":"python/function_arguments/#default-arguments","text":"Function Definition with default value for num2 and non-default value for num1 Default argument should be declare after the Non-default arguments #Default Arguments #num2 is default argument here def add(num1, num2=100): value1 = num1 value2 = num2 sum = value1 + value2 return sum #Function Calling result = add(10, 20) print(result) #Default argument is optional result = add(50) print(result) Output 30 150","title":"Default Arguments"},{"location":"python/function_arguments/#positional-arguments","text":"When we are calling the function, the order of passing arguments should be matched with the order of parameters in function definition #positional Arguments def add(num1, num2: value1 = num1 value2 = num2 sum = value1 + value2 return sum #Function Calling #Automatically 10 is assigns with num1 and 20 is assigns with num2 result = add(10, 20) print(result) Output 30 150","title":"Positional Arguments"},{"location":"python/function_arguments/#keyword-arguments","text":"In keyword arguments, we can change the order of the arguments by explicitly mentioned the function parameter name #Keyword Arguments def add(num1, num2): value1 = num1 value2 = num2 print(\"The value of num1 is : {}\".format(num1)) print(\"The value of num2 is : {}\".format(num2)) sum = value1 + value2 return sum #Function Calling with keyword arguments result = add(num2=10, num1=20) print(result) Output The value of num1 is : 20 The value of num2 is : 10 30","title":"Keyword Arguments"},{"location":"python/function_arguments/#arbitrary-positional-arguments","text":"When we are unsure on the number of parameters should be declare during function definition, asterisk (*) can place to get the dynamic positional arguments #Arbitrary Positional Arguments def add(*args): sum=0 for each in args: sum = sum + each return sum #Function Calling with Arbitrary Positional Arguments result = add(10, 20, 30) print(result) Output 60","title":"Arbitrary Positional Arguments"},{"location":"python/function_arguments/#arbitrary-keyword-arguments","text":"Double asterisk (**) can place to get the dynamic keyword arguments #Arbitrary Keyword Arguments def add(**args): sum=0 for key, value in args.items(): print(key, value) sum = sum + value return sum #Function Calling with Arbitrary Keyword Arguments result = add(num1=10, num2=20, num3=30) print(result) Output num1 10 num2 20 num3 30 60","title":"Arbitrary Keyword Arguments"},{"location":"python/inbuilt_functions/","text":"The top must known inbuilt function in python are Abs Function Abs function helps to return the absolute value of given number #Abs Function input_value = -50 output_value = abs(input_value) print(output_value) Output 50 All Function All function checks all the elements in the given iterable is true or not #All Function input_value = [10, 20, 30, 40] output_value = all(input_value) print(output_value) Output True Zero or False value in the given input returns false #All Function input_value = [10, 20, 30, 0] output_value = all(input_value) print(output_value) Output False Any Function Any function returns true if any one of the element is true in given iterable #Any Function input_value = [10, 20, 30, 0] output_value = any(input_value) print(output_value) Output True ASCII(Ord) Function Ord function helps to return the ASCII (American Standard Code for Information value of given character Interchange) #Ord Function input_value = \"R\" output_value = ord(input_value) print(output_value) Output 82 Bin Function Bin function helps to convert the decimal number to a binary string. Result have ob prefix which indicates the binary format #Bin Function input_value = 10 output_value = bin(input_value) print(output_value) Output 0b1010 Bool Function Bool functions returns the Boolean value (i.e.) either true or false #Bool Function input_value1 = 0 input_value2 = 1 output_value1 = bool(input_value1) print(output_value1) output_value2 = bool(input_value2) print(output_value2) Output False True Breakpoint Function In python 3.7, breakpoint function has introduced which helps to invoke breakpoint without import of pdb module. Previously we can use the pdb module, in which pdb.set_trace() function act as a breakpoint #Breakpoint Function input_value1 = 0 input_value2 = 1 output_value1 = bool(input_value1) print(output_value1) output_value2 = bool(input_value2) print(\"Want to continue? Press c and Enter\") breakpoint() print(output_value2) Output False Want to continue? Press c and Enter > <string>(12)<module>() (Pdb) c True Bytearray Function As per python documentation, Bytearray function Return a new array of bytes. The bytearray type is a mutable sequence of integers in the range 0 < x < 256. source [optional]: byte array initializer encoding [optional]: string encoding method errors [optional]: steps to perform during failure of encoding #ByteArray Function input_data = \"RATHNA SCHOOLS\" output1 = bytearray(input_data, \"utf-8\") print(output1) output2 = bytearray(input_data, \"utf-16\") print(output2) Output bytearray(b'RATHNA SCHOOLS') bytearray(b'\\xff\\xfeR\\x00A\\x00T\\x00H\\x00N\\x00A\\x00 \\x00S\\x00C\\x00H\\x00O\\x00O\\x00L\\x00S\\x00') Bytes Function Byte function is similar to bytearray but they returns a immutable bytes object, so it cannot be changed once declared #Bytes Function input_data = \"RATHNA SCHOOLS\" output1 = bytes(input_data, \"utf-8\") print(output1) output2 = bytes(input_data, \"utf-16\") print(output2) Output b'RATHNA SCHOOLS' b'\\xff\\xfeR\\x00A\\x00T\\x00H\\x00N\\x00A\\x00 \\x00S\\x00C\\x00H\\x00O\\x00O\\x00L\\x00S\\x00' Callable Function Callable function helps to check whether the given object argument is callable or not #Function1 def add(): return \"add function\" #Function2 def sub(): return \"sub function\" #Variable mul = \"mul function\" print(callable(add)) print(callable(sub)) #Its variable, not a callable function print(callable(mul)) Output True True False Chr Function Chr function helps to convert the ASCII value to its original character #Chr Function input_data = \"R\" #convert to ASCII value output_value1 = ord(input_data) print(output_value1) #Convert back to original character output_value2 = chr(output_value1) print(output_value2) Output 82 R Compile Function Compile method helps to convert the source code to an executable, so that it can execute whenever required syntax - compile(source, filename, mode) source - source code (it can single line or complete block filename - source code reading filename, if not we can pass random name mode - eval mode in case of single line, exec can use for multi line source code #Compile Function source_code = \"print('RATHNA SCHOOLS')\" compile_code = compile(source_code, \"Test\", \"eval\") eval(compile_code) Output RATHNA SCHOOLS Complex Function Complex function used to covert the string or number into a complex number #Complex Function input_data1 = complex(5,10) print(input_data1) input_data2 = complex(5) print(input_data2) Output (5+10j) (5+0j) Deltattr Function Deltattr function helps to delete the named attribute from the given object which should be allows it #Delattr Function class Score: python = 100 js = 90 java = 80 #Object Creation score_object = Score() #Before Deletion print(score_object.python) print(score_object.js) print(score_object.java) #After Deletion delattr(Score, 'java') print(score_object.python) print(score_object.js) print(score_object.java) Output 100 90 80 100 90 Traceback (most recent call last): File \"<string>\", line 19, in <module> AttributeError: 'Score' object has no attribute 'java' Dict Function Dict Function helps to create a new dictionary #Dict Function input_dict = dict( Name = \"Rathna Schools\", Language = \"Python\" ) print(input_dict) Output {'Name': 'Rathna Schools', 'Language': 'Python'} Dir Function Dir function is one of the most important built-in function in python. without parameter - It helps to return the list of name in current local scope with parameter - it helps to list the valid methods of given object in current local scope #Dir Function print(\"Without parameter\") print(dir()) print(\"With Parameter\") input_data = list() print(dir(input_data)) Output Without parameter ['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__'] With Parameter ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] Divmod Function Divmod function takes two arguments and return its quotient and remainder #Divmod Function input_value = 19 target_value = 3 result = divmod(input_value, target_value) print(result) Output (6, 1) Enumerate Function Enumerate function helps to create enumerate object by adding counter to iterable from 0 index #Enumerate Function month_list = [\"Jan\", \"Feb\", \"Mar\"] result = list(enumerate(month_list)) print(result) Output [(0, 'Jan'), (1, 'Feb'), (2, 'Mar')] Eval Function Eval function helps to evaluates the single expression and return the calculated result of that corresponding expression #Eval Function statement = \"print('Rathna Schools')\" eval(statement) Output Rathna Schools Exec Function Exec function helps to evaluates the one or more expression and return the calculated result of that corresponding expression or statement #Exec Function statement = \"for _ in range(0,3):\\n\\tprint('Rathna Schools')\" exec(statement) Output Rathna Schools Rathna Schools Rathna Schools Filter Function Filter function usually accepts two parameter, a function which should check each elements and the sequence which is needs to gets filtered #Filter Function def find_even(num): if num%2==0: return True input_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] result = list(filter(find_even, input_list)) print(result) Output [2, 4, 6, 8, 10] Format Function Format function helps to handle the complex string formatting representation easily in python input_name = \"Rathna Schools\" #Format Function Different Use Cases print(\"Learn Python - {0}\".format(input_name)) print(\"Learn Python - {}\".format(input_name)) print(\"The sum of {0} + {1} is {2}\".format(50, 100, 50+100)) print(\"The sum of {} + {} is {}\".format(50, 100, 50+100)) print(\"The sum of {num1} + {num2} is {result}\".format(num1=50, num2=100, result=50+100)) print(\"The sum of {num1} + {num2} is {result}\".format(num2=100, result=50+100, num1=50)) Output Learn Python - Rathna Schools Learn Python - Rathna Schools The sum of 50 + 100 is 150 The sum of 50 + 100 is 150 The sum of 50 + 100 is 150 The sum of 50 + 100 is 150 Hash Function Hash function helps to convert the given immutable data into hashable value #Hash Function input_name = \"Rathna Schools\" encoded_result = hash(input_name) #Every time generate new value print(encoded_result) #Immutable data raises exception input_list = [1, 2, 3, 4, 5] encoded_list = hash(input_list) print(encoded_list) Output 6055507806959227419 Traceback (most recent call last): File \"<string>\", line 9, in <module> TypeError: unhashable type: 'list' Hex Function Hex function helps to covert the given integer number to hexa decimal value #Hex Function input_num = 100 result = hex(input_num) print(result) Output 0x64 Id Function Id function helps to return the address of the given object in memory. As per python documentation, two objects with non-overlapping lifetimes may have the same id value. #Id Function input_num1 = 100 result1 = id(input_num1) print(result1) #Immutable data types with same value, have same memory location input_num2 = 100 result2 = id(input_num2) print(result2) #If we change the value, then memory location changes input_num2 = 50 result2 = id(input_num2) print(result2) Output 9792160 9792160 9790560 Input Function input() helps to interact with user and get the user's input in string format #Input Function input_name = input(\"Please enter the name : \") print(input_name) Output Please enter the name : Rathna Schools Rathna Schools Iter Function Iter function helps to convert the given sequence to iterator object. To access the elements in iterator we can use the next() function #Iter Function months = [\"Jan\" , \"Feb\", \"Mar\", \"Apr\"] iter_months = iter(months) try: while iter_months: print(next(iter_months)) except StopIteration: print(\"completed\") Output Jan Feb Mar Apr completed Locals Function Locals function helps to return a dict value of current local symbol table #Locals Function def func_without_local(): print(locals()) def func_with_local(): name = \"Rathna Schools\" print(locals()) #Return empty dict func_without_local() #Return local variable dict func_with_local() Output {} {'name': 'Rathna Schools'} Map Function Map function helps to apply the function and yield the results of each item in given sequence #Map Function def two_multiple(num): return num*2 input_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] result = list(map(two_multiple, input_list)) print(result) Output [2, 4, 6, 8, 10, 12, 14, 16, 18, 20] Object Function Object function helps to return a new feature less object which can be a base of all classes #Object Function obj_example = object() print(type(obj_example)) print(id(obj_example)) Output <class 'object'> 140529277524880 Repr Function Repr functions are similar to str() function but it return the printable string representation of the given object #Repr Function input_name = \"Rathna's Schools\" print(str(input_name)) print(repr(input_name)) Output Rathna's Schools \"Rathna's Schools\" Reversed Function Reversed function helps to reverse the given iterable and returns the reversed iterator #Reversed Function input_list = [1, 2, 3, 4, 5, 6, 7, 8, 9] print(list(reversed(input_list))) Output [9, 8, 7, 6, 5, 4, 3, 2, 1] Slice Function Slice function helps to return slice object from any sequence object like string, list, tuple etc.. Syntax slice(start, stop, step) #Slice Function input_list = [1, 2, 3, 4, 5, 6, 7, 8, 9] #Different Use Cases print(input_list[0:5]) print(input_list[3:8]) print(input_list[0:10:2]) Output [1, 2, 3, 4, 5] [4, 5, 6, 7, 8] [1, 3, 5, 7, 9] Zip Function zip(*iterable) function helps to return a ZIP object. we can pass multiple iterables as parameter to ZIP function in order to create a single zip object #Zip Function index_list = [1, 2, 3, 4, 5] month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"] for index, month in zip(index_list, month_list): print(index, month) Output 1 Jan 2 Feb 3 Mar 4 Apr 5 May","title":"Python Inbuilt Functions"},{"location":"python/inbuilt_functions/#abs-function","text":"Abs function helps to return the absolute value of given number #Abs Function input_value = -50 output_value = abs(input_value) print(output_value) Output 50","title":"Abs Function"},{"location":"python/inbuilt_functions/#all-function","text":"All function checks all the elements in the given iterable is true or not #All Function input_value = [10, 20, 30, 40] output_value = all(input_value) print(output_value) Output True Zero or False value in the given input returns false #All Function input_value = [10, 20, 30, 0] output_value = all(input_value) print(output_value) Output False","title":"All Function"},{"location":"python/inbuilt_functions/#any-function","text":"Any function returns true if any one of the element is true in given iterable #Any Function input_value = [10, 20, 30, 0] output_value = any(input_value) print(output_value) Output True","title":"Any Function"},{"location":"python/inbuilt_functions/#asciiord-function","text":"Ord function helps to return the ASCII (American Standard Code for Information value of given character Interchange) #Ord Function input_value = \"R\" output_value = ord(input_value) print(output_value) Output 82","title":"ASCII(Ord) Function"},{"location":"python/inbuilt_functions/#bin-function","text":"Bin function helps to convert the decimal number to a binary string. Result have ob prefix which indicates the binary format #Bin Function input_value = 10 output_value = bin(input_value) print(output_value) Output 0b1010","title":"Bin Function"},{"location":"python/inbuilt_functions/#bool-function","text":"Bool functions returns the Boolean value (i.e.) either true or false #Bool Function input_value1 = 0 input_value2 = 1 output_value1 = bool(input_value1) print(output_value1) output_value2 = bool(input_value2) print(output_value2) Output False True","title":"Bool Function"},{"location":"python/inbuilt_functions/#breakpoint-function","text":"In python 3.7, breakpoint function has introduced which helps to invoke breakpoint without import of pdb module. Previously we can use the pdb module, in which pdb.set_trace() function act as a breakpoint #Breakpoint Function input_value1 = 0 input_value2 = 1 output_value1 = bool(input_value1) print(output_value1) output_value2 = bool(input_value2) print(\"Want to continue? Press c and Enter\") breakpoint() print(output_value2) Output False Want to continue? Press c and Enter > <string>(12)<module>() (Pdb) c True","title":"Breakpoint Function"},{"location":"python/inbuilt_functions/#bytearray-function","text":"As per python documentation, Bytearray function Return a new array of bytes. The bytearray type is a mutable sequence of integers in the range 0 < x < 256. source [optional]: byte array initializer encoding [optional]: string encoding method errors [optional]: steps to perform during failure of encoding #ByteArray Function input_data = \"RATHNA SCHOOLS\" output1 = bytearray(input_data, \"utf-8\") print(output1) output2 = bytearray(input_data, \"utf-16\") print(output2) Output bytearray(b'RATHNA SCHOOLS') bytearray(b'\\xff\\xfeR\\x00A\\x00T\\x00H\\x00N\\x00A\\x00 \\x00S\\x00C\\x00H\\x00O\\x00O\\x00L\\x00S\\x00')","title":"Bytearray Function"},{"location":"python/inbuilt_functions/#bytes-function","text":"Byte function is similar to bytearray but they returns a immutable bytes object, so it cannot be changed once declared #Bytes Function input_data = \"RATHNA SCHOOLS\" output1 = bytes(input_data, \"utf-8\") print(output1) output2 = bytes(input_data, \"utf-16\") print(output2) Output b'RATHNA SCHOOLS' b'\\xff\\xfeR\\x00A\\x00T\\x00H\\x00N\\x00A\\x00 \\x00S\\x00C\\x00H\\x00O\\x00O\\x00L\\x00S\\x00'","title":"Bytes Function"},{"location":"python/inbuilt_functions/#callable-function","text":"Callable function helps to check whether the given object argument is callable or not #Function1 def add(): return \"add function\" #Function2 def sub(): return \"sub function\" #Variable mul = \"mul function\" print(callable(add)) print(callable(sub)) #Its variable, not a callable function print(callable(mul)) Output True True False","title":"Callable Function"},{"location":"python/inbuilt_functions/#chr-function","text":"Chr function helps to convert the ASCII value to its original character #Chr Function input_data = \"R\" #convert to ASCII value output_value1 = ord(input_data) print(output_value1) #Convert back to original character output_value2 = chr(output_value1) print(output_value2) Output 82 R","title":"Chr Function"},{"location":"python/inbuilt_functions/#compile-function","text":"Compile method helps to convert the source code to an executable, so that it can execute whenever required syntax - compile(source, filename, mode) source - source code (it can single line or complete block filename - source code reading filename, if not we can pass random name mode - eval mode in case of single line, exec can use for multi line source code #Compile Function source_code = \"print('RATHNA SCHOOLS')\" compile_code = compile(source_code, \"Test\", \"eval\") eval(compile_code) Output RATHNA SCHOOLS","title":"Compile Function"},{"location":"python/inbuilt_functions/#complex-function","text":"Complex function used to covert the string or number into a complex number #Complex Function input_data1 = complex(5,10) print(input_data1) input_data2 = complex(5) print(input_data2) Output (5+10j) (5+0j)","title":"Complex Function"},{"location":"python/inbuilt_functions/#deltattr-function","text":"Deltattr function helps to delete the named attribute from the given object which should be allows it #Delattr Function class Score: python = 100 js = 90 java = 80 #Object Creation score_object = Score() #Before Deletion print(score_object.python) print(score_object.js) print(score_object.java) #After Deletion delattr(Score, 'java') print(score_object.python) print(score_object.js) print(score_object.java) Output 100 90 80 100 90 Traceback (most recent call last): File \"<string>\", line 19, in <module> AttributeError: 'Score' object has no attribute 'java'","title":"Deltattr Function"},{"location":"python/inbuilt_functions/#dict-function","text":"Dict Function helps to create a new dictionary #Dict Function input_dict = dict( Name = \"Rathna Schools\", Language = \"Python\" ) print(input_dict) Output {'Name': 'Rathna Schools', 'Language': 'Python'}","title":"Dict Function"},{"location":"python/inbuilt_functions/#dir-function","text":"Dir function is one of the most important built-in function in python. without parameter - It helps to return the list of name in current local scope with parameter - it helps to list the valid methods of given object in current local scope #Dir Function print(\"Without parameter\") print(dir()) print(\"With Parameter\") input_data = list() print(dir(input_data)) Output Without parameter ['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__'] With Parameter ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']","title":"Dir Function"},{"location":"python/inbuilt_functions/#divmod-function","text":"Divmod function takes two arguments and return its quotient and remainder #Divmod Function input_value = 19 target_value = 3 result = divmod(input_value, target_value) print(result) Output (6, 1)","title":"Divmod Function"},{"location":"python/inbuilt_functions/#enumerate-function","text":"Enumerate function helps to create enumerate object by adding counter to iterable from 0 index #Enumerate Function month_list = [\"Jan\", \"Feb\", \"Mar\"] result = list(enumerate(month_list)) print(result) Output [(0, 'Jan'), (1, 'Feb'), (2, 'Mar')]","title":"Enumerate Function"},{"location":"python/inbuilt_functions/#eval-function","text":"Eval function helps to evaluates the single expression and return the calculated result of that corresponding expression #Eval Function statement = \"print('Rathna Schools')\" eval(statement) Output Rathna Schools","title":"Eval Function"},{"location":"python/inbuilt_functions/#exec-function","text":"Exec function helps to evaluates the one or more expression and return the calculated result of that corresponding expression or statement #Exec Function statement = \"for _ in range(0,3):\\n\\tprint('Rathna Schools')\" exec(statement) Output Rathna Schools Rathna Schools Rathna Schools","title":"Exec Function"},{"location":"python/inbuilt_functions/#filter-function","text":"Filter function usually accepts two parameter, a function which should check each elements and the sequence which is needs to gets filtered #Filter Function def find_even(num): if num%2==0: return True input_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] result = list(filter(find_even, input_list)) print(result) Output [2, 4, 6, 8, 10]","title":"Filter Function"},{"location":"python/inbuilt_functions/#format-function","text":"Format function helps to handle the complex string formatting representation easily in python input_name = \"Rathna Schools\" #Format Function Different Use Cases print(\"Learn Python - {0}\".format(input_name)) print(\"Learn Python - {}\".format(input_name)) print(\"The sum of {0} + {1} is {2}\".format(50, 100, 50+100)) print(\"The sum of {} + {} is {}\".format(50, 100, 50+100)) print(\"The sum of {num1} + {num2} is {result}\".format(num1=50, num2=100, result=50+100)) print(\"The sum of {num1} + {num2} is {result}\".format(num2=100, result=50+100, num1=50)) Output Learn Python - Rathna Schools Learn Python - Rathna Schools The sum of 50 + 100 is 150 The sum of 50 + 100 is 150 The sum of 50 + 100 is 150 The sum of 50 + 100 is 150","title":"Format Function"},{"location":"python/inbuilt_functions/#hash-function","text":"Hash function helps to convert the given immutable data into hashable value #Hash Function input_name = \"Rathna Schools\" encoded_result = hash(input_name) #Every time generate new value print(encoded_result) #Immutable data raises exception input_list = [1, 2, 3, 4, 5] encoded_list = hash(input_list) print(encoded_list) Output 6055507806959227419 Traceback (most recent call last): File \"<string>\", line 9, in <module> TypeError: unhashable type: 'list'","title":"Hash Function"},{"location":"python/inbuilt_functions/#hex-function","text":"Hex function helps to covert the given integer number to hexa decimal value #Hex Function input_num = 100 result = hex(input_num) print(result) Output 0x64","title":"Hex Function"},{"location":"python/inbuilt_functions/#id-function","text":"Id function helps to return the address of the given object in memory. As per python documentation, two objects with non-overlapping lifetimes may have the same id value. #Id Function input_num1 = 100 result1 = id(input_num1) print(result1) #Immutable data types with same value, have same memory location input_num2 = 100 result2 = id(input_num2) print(result2) #If we change the value, then memory location changes input_num2 = 50 result2 = id(input_num2) print(result2) Output 9792160 9792160 9790560","title":"Id Function"},{"location":"python/inbuilt_functions/#input-function","text":"input() helps to interact with user and get the user's input in string format #Input Function input_name = input(\"Please enter the name : \") print(input_name) Output Please enter the name : Rathna Schools Rathna Schools","title":"Input Function"},{"location":"python/inbuilt_functions/#iter-function","text":"Iter function helps to convert the given sequence to iterator object. To access the elements in iterator we can use the next() function #Iter Function months = [\"Jan\" , \"Feb\", \"Mar\", \"Apr\"] iter_months = iter(months) try: while iter_months: print(next(iter_months)) except StopIteration: print(\"completed\") Output Jan Feb Mar Apr completed","title":"Iter Function"},{"location":"python/inbuilt_functions/#locals-function","text":"Locals function helps to return a dict value of current local symbol table #Locals Function def func_without_local(): print(locals()) def func_with_local(): name = \"Rathna Schools\" print(locals()) #Return empty dict func_without_local() #Return local variable dict func_with_local() Output {} {'name': 'Rathna Schools'}","title":"Locals Function"},{"location":"python/inbuilt_functions/#map-function","text":"Map function helps to apply the function and yield the results of each item in given sequence #Map Function def two_multiple(num): return num*2 input_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] result = list(map(two_multiple, input_list)) print(result) Output [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]","title":"Map Function"},{"location":"python/inbuilt_functions/#object-function","text":"Object function helps to return a new feature less object which can be a base of all classes #Object Function obj_example = object() print(type(obj_example)) print(id(obj_example)) Output <class 'object'> 140529277524880","title":"Object Function"},{"location":"python/inbuilt_functions/#repr-function","text":"Repr functions are similar to str() function but it return the printable string representation of the given object #Repr Function input_name = \"Rathna's Schools\" print(str(input_name)) print(repr(input_name)) Output Rathna's Schools \"Rathna's Schools\"","title":"Repr Function"},{"location":"python/inbuilt_functions/#reversed-function","text":"Reversed function helps to reverse the given iterable and returns the reversed iterator #Reversed Function input_list = [1, 2, 3, 4, 5, 6, 7, 8, 9] print(list(reversed(input_list))) Output [9, 8, 7, 6, 5, 4, 3, 2, 1]","title":"Reversed Function"},{"location":"python/inbuilt_functions/#slice-function","text":"Slice function helps to return slice object from any sequence object like string, list, tuple etc.. Syntax slice(start, stop, step) #Slice Function input_list = [1, 2, 3, 4, 5, 6, 7, 8, 9] #Different Use Cases print(input_list[0:5]) print(input_list[3:8]) print(input_list[0:10:2]) Output [1, 2, 3, 4, 5] [4, 5, 6, 7, 8] [1, 3, 5, 7, 9]","title":"Slice Function"},{"location":"python/inbuilt_functions/#zip-function","text":"zip(*iterable) function helps to return a ZIP object. we can pass multiple iterables as parameter to ZIP function in order to create a single zip object #Zip Function index_list = [1, 2, 3, 4, 5] month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"] for index, month in zip(index_list, month_list): print(index, month) Output 1 Jan 2 Feb 3 Mar 4 Apr 5 May","title":"Zip Function"},{"location":"python/lambda_functions/","text":"As mentioned in previous chapter, python should use the def keyword to create functions but anonymous function can be create using lambda keyword. It should have only one expression, but we can pass multiple arguments Lambda vs Normal Functions Normal Function - To create multiple of ten for given number #Normal Function def calc(num): result = num * 10 return result output = calc(5) print(output) Output 50 Lambda function - To create multiple of ten for given number #Lambda Function calc = lambda x : x*10 output = calc(5) print(output) Output 50 Lambda with multiple argument We can pass multiple arguments to lambda functions #Lambda function with multiple arguments add = lambda x, y : x+y output = add(50, 100) print(output) Output 150 Lambda with map function #Lambda function along with map data = [1, 2, 3, 4, 5] output = list(map(lambda x : x*10, data)) print(output) Output [10, 20, 30, 40, 50] Lambda with filter function #Lambda function with filter data = [1, 2, 3, 4, 5] #Filter and return only even number in given list output = list(filter(lambda x : x%2==0, data)) print(output) Output [2, 4]","title":"Lambda Functions"},{"location":"python/lambda_functions/#lambda-vs-normal-functions","text":"Normal Function - To create multiple of ten for given number #Normal Function def calc(num): result = num * 10 return result output = calc(5) print(output) Output 50 Lambda function - To create multiple of ten for given number #Lambda Function calc = lambda x : x*10 output = calc(5) print(output) Output 50","title":"Lambda vs Normal Functions"},{"location":"python/lambda_functions/#lambda-with-multiple-argument","text":"We can pass multiple arguments to lambda functions #Lambda function with multiple arguments add = lambda x, y : x+y output = add(50, 100) print(output) Output 150","title":"Lambda with multiple argument"},{"location":"python/lambda_functions/#lambda-with-map-function","text":"#Lambda function along with map data = [1, 2, 3, 4, 5] output = list(map(lambda x : x*10, data)) print(output) Output [10, 20, 30, 40, 50]","title":"Lambda with map function"},{"location":"python/lambda_functions/#lambda-with-filter-function","text":"#Lambda function with filter data = [1, 2, 3, 4, 5] #Filter and return only even number in given list output = list(filter(lambda x : x%2==0, data)) print(output) Output [2, 4]","title":"Lambda with filter function"},{"location":"python/list_functions/","text":"Various built-in functions are available in Python which helps to perform multiple operations on list. Below are the top must know list methods in python Append Method This function helps to add a new element to the given list #Append Method month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"] print(\"List of element before appending: \") print(month_list) month_list.append(\"Jun\") print(\"List of element after appending: \") print(month_list) Output List of element before appending: ['Jan', 'Feb', 'Mar', 'Apr', 'May'] List of element after appending: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'] Insert Method This function helps to add a new element at specified index to the given list #Insert Method month_list = [\"Jan\", \"Feb\", \"Apr\", \"May\", \"Jun\"] print(\"List of element before inserting: \") print(month_list) month_list.insert(2, \"Mar\") print(\"List of element after inserting: \") print(month_list) Output List of element before inserting: ['Jan', 'Feb', 'Apr', 'May', 'Jun'] List of element after inserting: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'] Extend Method This function helps to extend another new list elements to the given list elements #Extend Method month_list = [\"Jan\", \"Feb\", \"Mar\"] month_list_new = [\"Apr\", \"May\", \"Jun\"] month_list.extend(month_list_new) print(\"List of element after appending: \") print(month_list) Output List of element after appending: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'] Clear Method This function helps to clear all the element in the given list #Clear Method month_list = [\"Jan\", \"Feb\", \"Mar\"] print(\"List of element before clearance: \") print(month_list) month_list.clear() print(\"List of element after clearance: \") print(month_list) Output List of element before clearance: ['Jan', 'Feb', 'Mar'] List of element after clearance: [] Pop Method This function helps to pop item at the specified index in the given list #Pop Method month_list = [\"Jan\", \"Feb\", \"Mar\", \"Dec\", \"Apr\", \"May\", \"Jun\"] print(\"List of element before pop method: \") print(month_list) month_list.pop(3) print(\"List of element after pop method: \") print(month_list) Output List of element before pop method: ['Jan', 'Feb', 'Mar', 'Dec', 'Apr', 'May', 'Jun'] List of element after pop method: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'] Sum Function This function returns the summation of all the values in the given list #Sum Function month_list = [10, 20, 30, 40, 50] print(\"The sum of list is : {}\".format(sum(month_list))) Output The sum of list is : 150 Count Method This function returns the total occurrence of given value in the given list #Count Function mark_list = [10, 20, 30, 10, 50, 60, 10, 60] print(\"The count of 10 in the list is : {}\".format(mark_list.count(10))) Output The count of 10 in the list is : 3 Length Function This function returns the total length of given list #length Function mark_list = [10, 20, 30, 10, 50, 60, 10, 60] print(\"The length of list is : {}\".format(len(mark_list))) Output The length of list is : 8 Index Method This function returns the index of first occurrence for the given value #Index Method mark_list = [10, 20, 30, 10, 50, 60, 10, 60] #Returns the index of first occurrence print(\"The index of 60 is : {}\".format(mark_list.index(60))) Output The index of 60 is : 5 Min Function This function returns the minimum value of given list #Min Function mark_list = [10, 20, 30, 10, 50, 60, 10, 60] #Returns the minimum element in the given list print(\"The minimum element in the given list is : {}\".format(min(mark_list))) Output The minimum element in the given list is : 10 Max Function This function returns the maximum value of the given list #Max Function mark_list = [10, 20, 30, 10, 50, 60, 10, 60] #Returns the maximum element in the given list print(\"The maximum element in the given list is : {}\".format(max(mark_list))) Output The maximum element in the given list is : 60 Sort Method Sort Method returns the sorting order of the given list #Sort Function mark_list = [10, 20, 30, 10, 50, 60, 10, 60] print(\"List before sorting : \") print(mark_list) mark_list.sort() print(\"List after sorting - ascending : \") print(mark_list) mark_list.sort(reverse=True) print(\"List after sorting - descending : \") print(mark_list) Output List before sorting : [10, 20, 30, 10, 50, 60, 10, 60] List after sorting - ascending : [10, 10, 10, 20, 30, 50, 60, 60] List after sorting - descending : [60, 60, 50, 30, 20, 10, 10, 10]","title":"List Functions"},{"location":"python/list_functions/#append-method","text":"This function helps to add a new element to the given list #Append Method month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"] print(\"List of element before appending: \") print(month_list) month_list.append(\"Jun\") print(\"List of element after appending: \") print(month_list) Output List of element before appending: ['Jan', 'Feb', 'Mar', 'Apr', 'May'] List of element after appending: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun']","title":"Append Method"},{"location":"python/list_functions/#insert-method","text":"This function helps to add a new element at specified index to the given list #Insert Method month_list = [\"Jan\", \"Feb\", \"Apr\", \"May\", \"Jun\"] print(\"List of element before inserting: \") print(month_list) month_list.insert(2, \"Mar\") print(\"List of element after inserting: \") print(month_list) Output List of element before inserting: ['Jan', 'Feb', 'Apr', 'May', 'Jun'] List of element after inserting: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun']","title":"Insert Method"},{"location":"python/list_functions/#extend-method","text":"This function helps to extend another new list elements to the given list elements #Extend Method month_list = [\"Jan\", \"Feb\", \"Mar\"] month_list_new = [\"Apr\", \"May\", \"Jun\"] month_list.extend(month_list_new) print(\"List of element after appending: \") print(month_list) Output List of element after appending: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun']","title":"Extend Method"},{"location":"python/list_functions/#clear-method","text":"This function helps to clear all the element in the given list #Clear Method month_list = [\"Jan\", \"Feb\", \"Mar\"] print(\"List of element before clearance: \") print(month_list) month_list.clear() print(\"List of element after clearance: \") print(month_list) Output List of element before clearance: ['Jan', 'Feb', 'Mar'] List of element after clearance: []","title":"Clear Method"},{"location":"python/list_functions/#pop-method","text":"This function helps to pop item at the specified index in the given list #Pop Method month_list = [\"Jan\", \"Feb\", \"Mar\", \"Dec\", \"Apr\", \"May\", \"Jun\"] print(\"List of element before pop method: \") print(month_list) month_list.pop(3) print(\"List of element after pop method: \") print(month_list) Output List of element before pop method: ['Jan', 'Feb', 'Mar', 'Dec', 'Apr', 'May', 'Jun'] List of element after pop method: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun']","title":"Pop Method"},{"location":"python/list_functions/#sum-function","text":"This function returns the summation of all the values in the given list #Sum Function month_list = [10, 20, 30, 40, 50] print(\"The sum of list is : {}\".format(sum(month_list))) Output The sum of list is : 150","title":"Sum Function"},{"location":"python/list_functions/#count-method","text":"This function returns the total occurrence of given value in the given list #Count Function mark_list = [10, 20, 30, 10, 50, 60, 10, 60] print(\"The count of 10 in the list is : {}\".format(mark_list.count(10))) Output The count of 10 in the list is : 3","title":"Count Method"},{"location":"python/list_functions/#length-function","text":"This function returns the total length of given list #length Function mark_list = [10, 20, 30, 10, 50, 60, 10, 60] print(\"The length of list is : {}\".format(len(mark_list))) Output The length of list is : 8","title":"Length Function"},{"location":"python/list_functions/#index-method","text":"This function returns the index of first occurrence for the given value #Index Method mark_list = [10, 20, 30, 10, 50, 60, 10, 60] #Returns the index of first occurrence print(\"The index of 60 is : {}\".format(mark_list.index(60))) Output The index of 60 is : 5","title":"Index Method"},{"location":"python/list_functions/#min-function","text":"This function returns the minimum value of given list #Min Function mark_list = [10, 20, 30, 10, 50, 60, 10, 60] #Returns the minimum element in the given list print(\"The minimum element in the given list is : {}\".format(min(mark_list))) Output The minimum element in the given list is : 10","title":"Min Function"},{"location":"python/list_functions/#max-function","text":"This function returns the maximum value of the given list #Max Function mark_list = [10, 20, 30, 10, 50, 60, 10, 60] #Returns the maximum element in the given list print(\"The maximum element in the given list is : {}\".format(max(mark_list))) Output The maximum element in the given list is : 60","title":"Max Function"},{"location":"python/list_functions/#sort-method","text":"Sort Method returns the sorting order of the given list #Sort Function mark_list = [10, 20, 30, 10, 50, 60, 10, 60] print(\"List before sorting : \") print(mark_list) mark_list.sort() print(\"List after sorting - ascending : \") print(mark_list) mark_list.sort(reverse=True) print(\"List after sorting - descending : \") print(mark_list) Output List before sorting : [10, 20, 30, 10, 50, 60, 10, 60] List after sorting - ascending : [10, 10, 10, 20, 30, 50, 60, 60] List after sorting - descending : [60, 60, 50, 30, 20, 10, 10, 10]","title":"Sort Method"},{"location":"python/python_abstraction/","text":"Abstraction helps to abstract or hide the internal logic of a function from the end user. User knows \"what the function does\" but no idea on \"how it does\". It reduces the overall application complexity and enhance application security. The abc module in python helps to achieve the abstraction in the program Abstract Class Below is an example for abstraction which is implemented with the help of abstract classes and methods #Abstract class from abc import ABC, abstractmethod class Shapes(ABC): @abstractmethod def number_of_sides(): pass class Square(Shapes): def number_of_sides(self): print(\"Square - Four Sides\") class Triangle(Shapes): def number_of_sides(self): print(\"Triangle - Three Sides\") class Pentagon(Shapes): def number_of_sides(self): print(\"Pentagon - Five Sides\") square = Square() square.number_of_sides() triangle = Triangle() triangle.number_of_sides() pentagon = Pentagon() pentagon.number_of_sides() Output Square - Four Sides Triangle - Three Sides Pentagon - Five Sides Abstract Methods Shaped(ABC) forces the child class to implement its abstract method. #Abstract Method from abc import ABC, abstractmethod class Shapes(ABC): @abstractmethod def number_of_sides(): pass class Circle(Shapes): def print_shape(self): print(\"I am circle\") circle = Circle() circle.print_shape() Output: Traceback (most recent call last): File \"<string>\", line 13, in <module> TypeError: Can't instantiate abstract class Circle with abstract methods number_of_sides To overcome this error, abstract methods helps to avoid the compulsory implementation #Abstract Methods from abc import ABC, abstractmethod #ABC - NotInherited class Shapes(): @abstractmethod def number_of_sides(): pass class Circle(Shapes): def print_shape(self): print(\"I am circle\") circle = Circle() circle.print_shape() Output I am circle","title":"Python Abstraction"},{"location":"python/python_abstraction/#abstract-class","text":"Below is an example for abstraction which is implemented with the help of abstract classes and methods #Abstract class from abc import ABC, abstractmethod class Shapes(ABC): @abstractmethod def number_of_sides(): pass class Square(Shapes): def number_of_sides(self): print(\"Square - Four Sides\") class Triangle(Shapes): def number_of_sides(self): print(\"Triangle - Three Sides\") class Pentagon(Shapes): def number_of_sides(self): print(\"Pentagon - Five Sides\") square = Square() square.number_of_sides() triangle = Triangle() triangle.number_of_sides() pentagon = Pentagon() pentagon.number_of_sides() Output Square - Four Sides Triangle - Three Sides Pentagon - Five Sides","title":"Abstract Class"},{"location":"python/python_abstraction/#abstract-methods","text":"Shaped(ABC) forces the child class to implement its abstract method. #Abstract Method from abc import ABC, abstractmethod class Shapes(ABC): @abstractmethod def number_of_sides(): pass class Circle(Shapes): def print_shape(self): print(\"I am circle\") circle = Circle() circle.print_shape() Output: Traceback (most recent call last): File \"<string>\", line 13, in <module> TypeError: Can't instantiate abstract class Circle with abstract methods number_of_sides To overcome this error, abstract methods helps to avoid the compulsory implementation #Abstract Methods from abc import ABC, abstractmethod #ABC - NotInherited class Shapes(): @abstractmethod def number_of_sides(): pass class Circle(Shapes): def print_shape(self): print(\"I am circle\") circle = Circle() circle.print_shape() Output I am circle","title":"Abstract Methods"},{"location":"python/python_closures/","text":"Before knowing the decorator concepts, its good to know about python closures Closure conditions To implement closures in python, below conditions should be matched It should have a nested Function Nested function should have a argument which pass from an enclosing(outer) function Nested function should be called inside outer function Nested function Below is the best and simple example to understand the Nested Function and python closures. Nested function can access the enclosed function variable without global declaration #Nested Function def outer_function(name): def inner_function(): print(\"The name is {}\".format(name)) inner_function() outer_function(\"Rathna Schools\") Output The name is Rathna Schools Closure creation Python closure stores the inner function state in a variable and call them whenever required like below #Python Closures def outer_function(name): def inner_function(): print(\"The name is {}\".format(name)) return inner_function result = outer_function(\"Rathna Schools\") #result variable behaves as independent inner function result() #Even though we deletes the outer function, closure variable survives in memory del outer_function result() Output The name is Rathna Schools The name is Rathna Schools When to use Instead of using class for simple scenario, closure serves like better than class implementation like the below example #Python Closures def ten_multiples(input_num): def multiply(): print(input_num*10) return multiply result1 = ten_multiples(2) result1() result2 = ten_multiples(5) result2() Output 20 50 As mentioned at beginning, decorators are extremely leveraging the benefits of closures. It is explained in next tutorial with simple examples","title":"Python Closures"},{"location":"python/python_closures/#closure-conditions","text":"To implement closures in python, below conditions should be matched It should have a nested Function Nested function should have a argument which pass from an enclosing(outer) function Nested function should be called inside outer function","title":"Closure conditions"},{"location":"python/python_closures/#nested-function","text":"Below is the best and simple example to understand the Nested Function and python closures. Nested function can access the enclosed function variable without global declaration #Nested Function def outer_function(name): def inner_function(): print(\"The name is {}\".format(name)) inner_function() outer_function(\"Rathna Schools\") Output The name is Rathna Schools","title":"Nested function"},{"location":"python/python_closures/#closure-creation","text":"Python closure stores the inner function state in a variable and call them whenever required like below #Python Closures def outer_function(name): def inner_function(): print(\"The name is {}\".format(name)) return inner_function result = outer_function(\"Rathna Schools\") #result variable behaves as independent inner function result() #Even though we deletes the outer function, closure variable survives in memory del outer_function result() Output The name is Rathna Schools The name is Rathna Schools","title":"Closure creation"},{"location":"python/python_closures/#when-to-use","text":"Instead of using class for simple scenario, closure serves like better than class implementation like the below example #Python Closures def ten_multiples(input_num): def multiply(): print(input_num*10) return multiply result1 = ten_multiples(2) result1() result2 = ten_multiples(5) result2() Output 20 50 As mentioned at beginning, decorators are extremely leveraging the benefits of closures. It is explained in next tutorial with simple examples","title":"When to use"},{"location":"python/python_comments/","text":"Every programming language having the facility for comments. Python also provides the best commenting system which is used to increase the readability of the code Types of Comments 1. Single Line Comments 2. Docstring Comments 3. Multiline Comments Single Line Comments Use the hash symbol to write a single-line comment #Single Line Comment print(\"I'm print statement with single line comment\") Output I'm print statement with single line comment Docstring Comments We can use multi-line docstring as multiline comments. A multi-line docstring starts with triple quotes (\"\"\") and ends with triple quotes (\"\"\") \"\"\"The multiline comment using Docstring method\"\"\" print(\"I'm print statement with Docstring comment\") Output I'm print statement with Docstring comment Multi Line Comments Python does not really have a syntax for multi line comments. We should insert # for each line or use the above mentioned Docstring method to add a multi line comments # The multiline comment # by inserting hash # in each line of code print(\"I'm print statement with Multiline comment\") Output I'm print statement with Multiline comment","title":"Python Comments"},{"location":"python/python_comments/#types-of-comments","text":"1. Single Line Comments 2. Docstring Comments 3. Multiline Comments","title":"Types of Comments"},{"location":"python/python_comments/#single-line-comments","text":"Use the hash symbol to write a single-line comment #Single Line Comment print(\"I'm print statement with single line comment\") Output I'm print statement with single line comment","title":"Single Line Comments"},{"location":"python/python_comments/#docstring-comments","text":"We can use multi-line docstring as multiline comments. A multi-line docstring starts with triple quotes (\"\"\") and ends with triple quotes (\"\"\") \"\"\"The multiline comment using Docstring method\"\"\" print(\"I'm print statement with Docstring comment\") Output I'm print statement with Docstring comment","title":"Docstring Comments"},{"location":"python/python_comments/#multi-line-comments","text":"Python does not really have a syntax for multi line comments. We should insert # for each line or use the above mentioned Docstring method to add a multi line comments # The multiline comment # by inserting hash # in each line of code print(\"I'm print statement with Multiline comment\") Output I'm print statement with Multiline comment","title":"Multi Line Comments"},{"location":"python/python_data_types/","text":"Data types specify the different sizes and values that can be stored in the variable. Each and everything is an object in Python programming language, so below data-types are classes and the variables are instance of that classes. Built-In Data Types Numeric Types # int, float and complex Text Type # str Sequence Types # list, tuple, range Mapping Type # dict Set Types # set, frozenset Boolean Type # bool Binary Types # bytes, bytesarray, memoryview ** Note - you can use any online python interpreter to run and test the below python programs Numeric Data Types There are three distinct numeric types: integers, floating point numbers, and complex numbers. They are defined as int, float and complex classes in Python. #Numeric data types num1 = 5 print(type(num1)) num2 = 5.0 print(type(num2)) num3 = 5+2j print(type(num3)) Output <class 'int'> <class 'float'> <class 'complex'> Text Data Type Textual data in Python is handled with str objects, or strings. #String data type name = \"RATHNA SCHOOLS\" print(type(name)) #String literals are written in a variety of ways data = 'allows embedded \"double\" quotes' print(data) data = \"allows embedded 'single' quotes\" print(data) Output <class 'str'> allows embedded \"double\" quotes allows embedded 'single' quotes Sequence Data Types There are three basic sequence types: lists, tuples, and range objects #List data type #Mutable (values can be change after declaration) list_data = [1, 5.0, \"RATHNA SCHOOLS\"] print(type(list_data)) #Tuple data type #Immutable (values cannot be change after declaration) tuple_data = (1, 5.0, \"RATHNA SCHOOLS\") print(type(tuple_data)) #Range data type range_data = range(1, 10) print(type(range_data)) Output <class 'list'> <class 'tuple'> <class 'range'> Mapping Data Type Dictionary is an unordered collection of key-value pairs. Dictionaries can be created by placing a comma-separated list of key: value pairs within braces #Dict data type dict_data = {\"ID\":12345, \"Name\": \"RATHNA SCHOOLS\"} print(type(dict_data)) print(dict_data[\"ID\"]) print(dict_data[\"Name\"]) Output <class 'dict'> 12345 RATHNA SCHOOLS Set Data Types A set is an unordered collection of items. Major use case with set are membership testing, removing duplicates from a sequence, and computing mathematical operations such as intersection, union, difference, and symmetric difference #Set data types set_data = {1, 2.0, \"Rathna Schools\"} print(set_data) #Elements can add after declaration set_data.add(\"5\") print(set_data) #Frozen set Months = [\"Jan\", \"Feb\", \"Mar\"] frozen_set_data = frozenset(Months) print(frozen_set_data) #Elements cannot add after declaration frozen_set_data.add(\"5\") print(frozen_set_data) Output {'Rathna Schools', 1, 2.0} {'Rathna Schools', 1, 2.0, '5'} frozenset({'Mar', 'Jan', 'Feb'}) Traceback (most recent call last): File \"<string>\", line 13, in <module> AttributeError: 'frozenset' object has no attribute 'add' Boolean Data Type Boolean data type can be used to test the truth value. It always return either True or False as output which can be used in conditional and looping statements #Bool data types bool_data = True print(type(bool_data)) print(bool_data) Output <class 'bool'> True Binary Data Types Bytes and Bytearray are used for manipulating binary data. The memoryview uses the buffer protocol to access the memory of other binary objects without needing to make a copy #Binary data types #Byte byte_data = b'RATHNA SCHOOLS' print(type(byte_data)) print(byte_data) #Byte Array byte_array_data = bytearray(byte_data) print(type(byte_array_data)) print(byte_array_data) #Memoryview memoryview_data = memoryview(byte_data) print(type(memoryview_data)) print(memoryview_data) Output <class 'bytes'> b'RATHNA SCHOOLS' <class 'bytearray'> bytearray(b'RATHNA SCHOOLS') <class 'memoryview'> <memory at 0x7f814b6b9280>","title":"Python Data Types"},{"location":"python/python_data_types/#built-in-data-types","text":"Numeric Types # int, float and complex Text Type # str Sequence Types # list, tuple, range Mapping Type # dict Set Types # set, frozenset Boolean Type # bool Binary Types # bytes, bytesarray, memoryview ** Note - you can use any online python interpreter to run and test the below python programs","title":"Built-In Data Types"},{"location":"python/python_data_types/#numeric-data-types","text":"There are three distinct numeric types: integers, floating point numbers, and complex numbers. They are defined as int, float and complex classes in Python. #Numeric data types num1 = 5 print(type(num1)) num2 = 5.0 print(type(num2)) num3 = 5+2j print(type(num3)) Output <class 'int'> <class 'float'> <class 'complex'>","title":"Numeric Data Types"},{"location":"python/python_data_types/#text-data-type","text":"Textual data in Python is handled with str objects, or strings. #String data type name = \"RATHNA SCHOOLS\" print(type(name)) #String literals are written in a variety of ways data = 'allows embedded \"double\" quotes' print(data) data = \"allows embedded 'single' quotes\" print(data) Output <class 'str'> allows embedded \"double\" quotes allows embedded 'single' quotes","title":"Text Data Type"},{"location":"python/python_data_types/#sequence-data-types","text":"There are three basic sequence types: lists, tuples, and range objects #List data type #Mutable (values can be change after declaration) list_data = [1, 5.0, \"RATHNA SCHOOLS\"] print(type(list_data)) #Tuple data type #Immutable (values cannot be change after declaration) tuple_data = (1, 5.0, \"RATHNA SCHOOLS\") print(type(tuple_data)) #Range data type range_data = range(1, 10) print(type(range_data)) Output <class 'list'> <class 'tuple'> <class 'range'>","title":"Sequence Data Types"},{"location":"python/python_data_types/#mapping-data-type","text":"Dictionary is an unordered collection of key-value pairs. Dictionaries can be created by placing a comma-separated list of key: value pairs within braces #Dict data type dict_data = {\"ID\":12345, \"Name\": \"RATHNA SCHOOLS\"} print(type(dict_data)) print(dict_data[\"ID\"]) print(dict_data[\"Name\"]) Output <class 'dict'> 12345 RATHNA SCHOOLS","title":"Mapping Data Type"},{"location":"python/python_data_types/#set-data-types","text":"A set is an unordered collection of items. Major use case with set are membership testing, removing duplicates from a sequence, and computing mathematical operations such as intersection, union, difference, and symmetric difference #Set data types set_data = {1, 2.0, \"Rathna Schools\"} print(set_data) #Elements can add after declaration set_data.add(\"5\") print(set_data) #Frozen set Months = [\"Jan\", \"Feb\", \"Mar\"] frozen_set_data = frozenset(Months) print(frozen_set_data) #Elements cannot add after declaration frozen_set_data.add(\"5\") print(frozen_set_data) Output {'Rathna Schools', 1, 2.0} {'Rathna Schools', 1, 2.0, '5'} frozenset({'Mar', 'Jan', 'Feb'}) Traceback (most recent call last): File \"<string>\", line 13, in <module> AttributeError: 'frozenset' object has no attribute 'add'","title":"Set Data Types"},{"location":"python/python_data_types/#boolean-data-type","text":"Boolean data type can be used to test the truth value. It always return either True or False as output which can be used in conditional and looping statements #Bool data types bool_data = True print(type(bool_data)) print(bool_data) Output <class 'bool'> True","title":"Boolean Data Type"},{"location":"python/python_data_types/#binary-data-types","text":"Bytes and Bytearray are used for manipulating binary data. The memoryview uses the buffer protocol to access the memory of other binary objects without needing to make a copy #Binary data types #Byte byte_data = b'RATHNA SCHOOLS' print(type(byte_data)) print(byte_data) #Byte Array byte_array_data = bytearray(byte_data) print(type(byte_array_data)) print(byte_array_data) #Memoryview memoryview_data = memoryview(byte_data) print(type(memoryview_data)) print(memoryview_data) Output <class 'bytes'> b'RATHNA SCHOOLS' <class 'bytearray'> bytearray(b'RATHNA SCHOOLS') <class 'memoryview'> <memory at 0x7f814b6b9280>","title":"Binary Data Types"},{"location":"python/python_decorators/","text":"Decorators are used to modify the existing functionality without changing the existing code of that function. A function is modify with another function at compile time is also called as meta programming Simple Decorators Like the below example, we can implement the decorators for the normal function to implement more functionality #Normal Function without decorators def school_name(name): print(\"The school name is {}\".format(name)) school_name(\"Rathna Schools\") Output The school name is Rathna Schools Incase, business request to implement pretty text for the existing function means, we can develop decorator like below to extend its functionality without modification in it #Decorator Implementation def simple_decorator(func): def make_pretty(input_data): print(\"Make Pretty - Implementation\") func(input_data) return make_pretty @simple_decorator def school_name(name): print(\"The school name is {}\".format(name)) school_name(\"Rathna Schools\") Output Make Pretty - Implementation The school name is Rathna Schools Realtime Example 1 Implementation of exception handling decorators like the below example to handle exception #Normal function without any exception def divide(dividend, divisor): print(\"The quotient is {}\".format(str(dividend//divisor))) print(\"The remainder is {}\".format(str(dividend%divisor))) #This work without any exception divide(100,3) #This raise zero division exception divide(75, 0) Output The quotient is 33 The remainder is 1 Traceback (most recent call last): File \"<string>\", line 7, in <module> File \"<string>\", line 3, in divide ZeroDivisionError: integer division or modulo by zero Handle above exception with decorators without any modification in existing function #Exception handling decorators def exception_handler(func): def inner_func(num1, num2): try: func(num1, num2) except ZeroDivisionError: print(\"Divisor should not be Zero\") return inner_func @exception_handler def divide(dividend, divisor): print(\"The quotient is {}\".format(str(dividend//divisor))) print(\"The remainder is {}\".format(str(dividend%divisor))) #This work without any exception divide(100,3) #Now this handles by exception handler decorator divide(75, 0) Output The quotient is 33 The remainder is 1 Divisor should not be Zero Realtime Example 2 Database connection decorator implementation for the required function to perform the database operation like the below example #DB connector decorator def make_connection(func): def inner_func(*args, **kwargs): print(\"DB connection - Successful\") func(*args, **kwargs) return inner_func @make_connection def read_user(*args, **kwargs): query = \"select * from {} where id={}\".format(args[0], kwargs['user_id']) print(query) read_user(\"users\", user_id=\"1234\") Output DB connection - Successful select * from users where id=1234","title":"Python Decorators"},{"location":"python/python_decorators/#simple-decorators","text":"Like the below example, we can implement the decorators for the normal function to implement more functionality #Normal Function without decorators def school_name(name): print(\"The school name is {}\".format(name)) school_name(\"Rathna Schools\") Output The school name is Rathna Schools Incase, business request to implement pretty text for the existing function means, we can develop decorator like below to extend its functionality without modification in it #Decorator Implementation def simple_decorator(func): def make_pretty(input_data): print(\"Make Pretty - Implementation\") func(input_data) return make_pretty @simple_decorator def school_name(name): print(\"The school name is {}\".format(name)) school_name(\"Rathna Schools\") Output Make Pretty - Implementation The school name is Rathna Schools","title":"Simple Decorators"},{"location":"python/python_decorators/#realtime-example-1","text":"Implementation of exception handling decorators like the below example to handle exception #Normal function without any exception def divide(dividend, divisor): print(\"The quotient is {}\".format(str(dividend//divisor))) print(\"The remainder is {}\".format(str(dividend%divisor))) #This work without any exception divide(100,3) #This raise zero division exception divide(75, 0) Output The quotient is 33 The remainder is 1 Traceback (most recent call last): File \"<string>\", line 7, in <module> File \"<string>\", line 3, in divide ZeroDivisionError: integer division or modulo by zero Handle above exception with decorators without any modification in existing function #Exception handling decorators def exception_handler(func): def inner_func(num1, num2): try: func(num1, num2) except ZeroDivisionError: print(\"Divisor should not be Zero\") return inner_func @exception_handler def divide(dividend, divisor): print(\"The quotient is {}\".format(str(dividend//divisor))) print(\"The remainder is {}\".format(str(dividend%divisor))) #This work without any exception divide(100,3) #Now this handles by exception handler decorator divide(75, 0) Output The quotient is 33 The remainder is 1 Divisor should not be Zero","title":"Realtime Example 1"},{"location":"python/python_decorators/#realtime-example-2","text":"Database connection decorator implementation for the required function to perform the database operation like the below example #DB connector decorator def make_connection(func): def inner_func(*args, **kwargs): print(\"DB connection - Successful\") func(*args, **kwargs) return inner_func @make_connection def read_user(*args, **kwargs): query = \"select * from {} where id={}\".format(args[0], kwargs['user_id']) print(query) read_user(\"users\", user_id=\"1234\") Output DB connection - Successful select * from users where id=1234","title":"Realtime Example 2"},{"location":"python/python_dictionary/","text":"Dictionary in Python is an unordered collection of data values, used to store data values like a map, which, unlike other Data Types that hold only a single value as an element, Dictionary holds key:value pair. Key-value is provided in the dictionary to make it more optimized. Dictionary Creation Dictionary can create using curly brackets with keys(should have only immutable data type-string, tuple, int) and values(accept all data types) #Dictionary Creation language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\" } print(\"Dictionary Creation : \") print(language_dict) Output Dictionary Creation : {1: 'Python', 2: 'Java', 3: 'JavaScript'} Key should be unique - duplicate key creation replace the existing Value #Dictionary Creation language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", 1 : \"C++\" } print(\"Duplicate keys overrides: \") print(language_dict) Output Duplicate keys overrides: {1: 'C++', 2: 'Java', 3: 'JavaScript'} Dictionary Access To access dictionary - we can use the key and value function or iterating each items in the given dictionary #Dictionary Access language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", } print(\"Access using key : \") print(language_dict[1]) print(\"Iteration - To access all value\") for key, value in language_dict.items(): print(key, value) Output Access using key : Python Iteration - To access all value 1 Python 2 Java 3 JavaScript Dictionary update Dictionary can be update using the update function #Dictionary Update language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", } print(\"Update using key : \") language_dict[1] = \"C++\" print(language_dict) print(\"Update using update method\") language_dict.update({1 : \"Python\"}) print(language_dict) Output Update using key : {1: 'C++', 2: 'Java', 3: 'JavaScript'} Update using update method {1: 'Python', 2: 'Java', 3: 'JavaScript'} Dictionary update Since dictionary is mutable, we can perform the specific deletion operation #Dictionary Update language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", 4 : \"C++\" } print(\"Delete using key : \") language_dict.pop(4) print(language_dict) print(\"Delete using 'del' keyword\") del language_dict[3] print(language_dict) Output Delete using key : {1: 'Python', 2: 'Java', 3: 'JavaScript'} Delete using 'del' keyword {1: 'Python', 2: 'Java'} Dictionary Slicing Since dictionary are unordered collection, we cannot perform the slicing operation in dictionary data #Dictionary Slicing language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", 4 : \"C++\" } print(\"Dictionary slicing raises exception : \") print(language_dict[1:4]) Output Dictionary slicing raises exception : Traceback (most recent call last): File \"<string>\", line 10, in <module> TypeError: unhashable type: 'slice'","title":"Python Dictionary"},{"location":"python/python_dictionary/#dictionary-creation","text":"Dictionary can create using curly brackets with keys(should have only immutable data type-string, tuple, int) and values(accept all data types) #Dictionary Creation language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\" } print(\"Dictionary Creation : \") print(language_dict) Output Dictionary Creation : {1: 'Python', 2: 'Java', 3: 'JavaScript'} Key should be unique - duplicate key creation replace the existing Value #Dictionary Creation language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", 1 : \"C++\" } print(\"Duplicate keys overrides: \") print(language_dict) Output Duplicate keys overrides: {1: 'C++', 2: 'Java', 3: 'JavaScript'}","title":"Dictionary Creation"},{"location":"python/python_dictionary/#dictionary-access","text":"To access dictionary - we can use the key and value function or iterating each items in the given dictionary #Dictionary Access language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", } print(\"Access using key : \") print(language_dict[1]) print(\"Iteration - To access all value\") for key, value in language_dict.items(): print(key, value) Output Access using key : Python Iteration - To access all value 1 Python 2 Java 3 JavaScript","title":"Dictionary Access"},{"location":"python/python_dictionary/#dictionary-update","text":"Dictionary can be update using the update function #Dictionary Update language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", } print(\"Update using key : \") language_dict[1] = \"C++\" print(language_dict) print(\"Update using update method\") language_dict.update({1 : \"Python\"}) print(language_dict) Output Update using key : {1: 'C++', 2: 'Java', 3: 'JavaScript'} Update using update method {1: 'Python', 2: 'Java', 3: 'JavaScript'}","title":"Dictionary update"},{"location":"python/python_dictionary/#dictionary-update_1","text":"Since dictionary is mutable, we can perform the specific deletion operation #Dictionary Update language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", 4 : \"C++\" } print(\"Delete using key : \") language_dict.pop(4) print(language_dict) print(\"Delete using 'del' keyword\") del language_dict[3] print(language_dict) Output Delete using key : {1: 'Python', 2: 'Java', 3: 'JavaScript'} Delete using 'del' keyword {1: 'Python', 2: 'Java'}","title":"Dictionary update"},{"location":"python/python_dictionary/#dictionary-slicing","text":"Since dictionary are unordered collection, we cannot perform the slicing operation in dictionary data #Dictionary Slicing language_dict = { 1 : \"Python\", 2 : \"Java\", 3 : \"JavaScript\", 4 : \"C++\" } print(\"Dictionary slicing raises exception : \") print(language_dict[1:4]) Output Dictionary slicing raises exception : Traceback (most recent call last): File \"<string>\", line 10, in <module> TypeError: unhashable type: 'slice'","title":"Dictionary Slicing"},{"location":"python/python_encapsulation/","text":"Encapsulation is one of the major concept in object oriented programming. It helps to wrap up data and methods into a single unit. Through encapsulation, we can achieve the security and prevent the accidental modification of any attributes in a class Access Modifiers Below are the three different types of access modifiers available in python 1. Public Members 2. Private Members 3. Protected Members Access Modifiers Own class access Derived class access object access private member YES NO NO protected member YES YES NO public member YES YES YES Public Members Public members can be accessed from anywhere in the program #ENCAPSULATION class Department: department = \"CS\" class Student(Department): def __init__(self, name, age): self.name = name self.age = 18 def get_student_age(self): return \"Age of the student is : {}\".format(self.age) def get_department_name(self): return \"Department of the student is : {}\".format(self.department) student = Student(\"John\", 18) #Public members can access from anywhere print(\"Name of the student is : {}\".format(student.name)) print(student.get_student_age()) print(student.get_department_name()) Output Name of the student is : John Age of the student is : 18 Department of the student is : CS Protected Members Protected members cannot be accessed in the child class like the below example #ENCAPSULATION class Department: _department = \"CS\" class Student(Department): def __init__(self, name, age): self.name = name self.age = 18 def get_student_age(self): return \"Age of the student is : {}\".format(self.age) #Child accessing parent protected member- raises exception def get_department_name(self): return \"Department of the student is : {}\".format(self.department) student = Student(\"John\", 18) print(\"Name of the student is : {}\".format(student.name)) print(student.get_student_age()) print(student.get_department_name()) Output Name of the student is : John Age of the student is : 18 Traceback (most recent call last): File \"<string>\", line 21, in <module> File \"<string>\", line 15, in get_department_name AttributeError: 'Student' object has no attribute 'department' Private Members Private members cannot be accessed in the child class and its own objects too #ENCAPSULATION class Department: department = \"CS\" class Student(Department): def __init__(self, name, age): self.__name = name self.__age = 18 def get_student_age(self): return \"Age of the student is : {}\".format(self.__age) #Child accessing parent protected member- raises exception def get_department_name(self): return \"Department of the student is : {}\".format(self.department) student = Student(\"John\", 18) print(student.get_student_age()) #Raises Exception - Private members cannot access via object print(\"Name of the student is : {}\".format(student.__name)) print(student.get_department_name()) Output Age of the student is : 18 Traceback (most recent call last): File \"<string>\", line 20, in <module> AttributeError: 'Student' object has no attribute '__name'","title":"Python Encapsulation"},{"location":"python/python_encapsulation/#access-modifiers","text":"Below are the three different types of access modifiers available in python 1. Public Members 2. Private Members 3. Protected Members Access Modifiers Own class access Derived class access object access private member YES NO NO protected member YES YES NO public member YES YES YES","title":"Access Modifiers"},{"location":"python/python_encapsulation/#public-members","text":"Public members can be accessed from anywhere in the program #ENCAPSULATION class Department: department = \"CS\" class Student(Department): def __init__(self, name, age): self.name = name self.age = 18 def get_student_age(self): return \"Age of the student is : {}\".format(self.age) def get_department_name(self): return \"Department of the student is : {}\".format(self.department) student = Student(\"John\", 18) #Public members can access from anywhere print(\"Name of the student is : {}\".format(student.name)) print(student.get_student_age()) print(student.get_department_name()) Output Name of the student is : John Age of the student is : 18 Department of the student is : CS","title":"Public Members"},{"location":"python/python_encapsulation/#protected-members","text":"Protected members cannot be accessed in the child class like the below example #ENCAPSULATION class Department: _department = \"CS\" class Student(Department): def __init__(self, name, age): self.name = name self.age = 18 def get_student_age(self): return \"Age of the student is : {}\".format(self.age) #Child accessing parent protected member- raises exception def get_department_name(self): return \"Department of the student is : {}\".format(self.department) student = Student(\"John\", 18) print(\"Name of the student is : {}\".format(student.name)) print(student.get_student_age()) print(student.get_department_name()) Output Name of the student is : John Age of the student is : 18 Traceback (most recent call last): File \"<string>\", line 21, in <module> File \"<string>\", line 15, in get_department_name AttributeError: 'Student' object has no attribute 'department'","title":"Protected Members"},{"location":"python/python_encapsulation/#private-members","text":"Private members cannot be accessed in the child class and its own objects too #ENCAPSULATION class Department: department = \"CS\" class Student(Department): def __init__(self, name, age): self.__name = name self.__age = 18 def get_student_age(self): return \"Age of the student is : {}\".format(self.__age) #Child accessing parent protected member- raises exception def get_department_name(self): return \"Department of the student is : {}\".format(self.department) student = Student(\"John\", 18) print(student.get_student_age()) #Raises Exception - Private members cannot access via object print(\"Name of the student is : {}\".format(student.__name)) print(student.get_department_name()) Output Age of the student is : 18 Traceback (most recent call last): File \"<string>\", line 20, in <module> AttributeError: 'Student' object has no attribute '__name'","title":"Private Members"},{"location":"python/python_exceptions/","text":"With the help of try, catch and finally statements, we can handle the exceptions in python programming. Lot of inbuilt exception are available in python which are raised if the program encounters an error Built-In Exceptions Below are the list of inbuilt exception which occurs at runtime due to logical errors Exception Reason for exception Assertion Error occurs during the failure of assert statements Attribute Error occurs during the failure of attribute assignment EOF Error occurs when the input function reaches the end of file condition Floatingpoint Error occurs during the failure of floating point operations GeneratorExit Error occurs if the closed method is called in generator Import Error occurs if the imported module is not found KeyError Error occurs during the failure of founding key in given dict KeyInterrupt Error occurs if the console receives delete or ctrl+c commands Memory Error occurs if the memory exceeds the limit Name Error occurs if the variable is not available in the given scope NotImplemented Error occurs if the class not implemented the abstract methods OS Error occurs during the system related failures Overflow Error occurs during the failure to represent large arithmetic operation Reference Error occurs during the garbage collected referent access by a week reference proxy Runtime Error occurs during the occurrence of unidentified exception Stopiteration Error occurs when the iterator function not having any other items to iterate Syntax Error occurs during the error in program syntax Indentation Error occurs due to incorrect indentation Tab Error occurs due to inconsistent tabs or spaces in indentation System Error occurs due to the internal error faced by interpreter System Exit occurs due to sys.exit function Type Error occurs due to the incorrect object type Unboundlocal Error occurs due to the missing of value for the given variable in a function Unicode Error occurs due to the error in unicode related encoding and decoding UnicodeEncode Error occurs due to the error in unicode related encoding UnicodeDecode Error occurs due to the error in unicode related decoding UnicodeTranslate Error occurs due to the error in unicode related translating Value Error occurs due to the improper value for the passed arguments with correct type ZeroDivision Error occurs due to zero value in division or modulo operation's second operand Try and Except clause The major functionality which can raise exception should be declare inside try statement and the code which handles the raised exception should be declare inside the except clause like the below sample program #Exception Handling num1 = 10 num2 = 0 try: result = num1//num2 except: print(\"Exception occurs during division operation\") Output Exception during division operation Try and Multiple Except clause Its not a good practice the exception in very general way like the above program. We should handle the exception based on the type of exception raises like the below programs Program 1: Handling Zero Division Exception #Handling Zero Division Exception num1 = 10 num2 = 0 try: result = num1//num2 except ZeroDivisionError: print(\"The second operand value shouldn't be zero of division operation\") except TypeError: print(\"The division operation cannot be perform for non integer type objects\") except Exception as E: print(\"Exception occurs during division operation\") Output The second operand value shouldn't be zero of division operation Program 2: Handling invalid type Exception #Handling invalid type Exception num1 = 10 num2 = \"0\" try: result = num1//num2 except ZeroDivisionError: print(\"The second operand value shouldn't be zero of division operation\") except TypeError: print(\"The division operation cannot be perform for non integer objects\") except Exception as E: print(\"Exception occurs during division operation\") Output The division operation cannot be perform for non integer objects Program 3: Handling General Exceptions #Handling general Exception num1 = 10 try: result = num1//num2 except ZeroDivisionError: print(\"The second operand value shouldn't be zero of division operation\") except TypeError: print(\"The division operation cannot be perform for non integer objects\") except Exception as E: print(\"Exception occurs during division operation\") Output Exception occurs during division operation Try, Except and Else clause After the successful execution of try statement, if we want to execute some other code that can be handle in else clause. If no exception occurs in execution, else clause block executes by the interpreter #Else clause num1 = 10 num2 = 5 try: result = num1//num2 except ZeroDivisionError: print(\"The second operand value shouldn't be zero of division operation\") except TypeError: print(\"The division operation cannot be perform for non integer objects\") except Exception as E: print(\"Exception occurs during division operation\") else: print(result) Output 2 Try, Except and Finally clause Finally clause executes for both successful and exceptional cases. Usually it uses for cleanup the resources like the below program Program 1: Finally clause - Successful scenario #Finally clause num1 = 10 num2 = 2 try: result = num1//num2 print(result) except ZeroDivisionError: print(\"The second operand value shouldn't be zero of division operation\") except TypeError: print(\"The division operation cannot be perform for non integer objects\") except Exception as E: print(\"Exception occurs during division operation\") finally: del num1 del num2 print(\"Finally clause Executed\") Output 5 Finally clause Executed Program 2: Finally clause - Exception scenario #Finally clause num1 = 10 num2 = 0 try: result = num1//num2 print(result) except ZeroDivisionError: print(\"The second operand value shouldn't be zero of division operation\") except TypeError: print(\"The division operation cannot be perform for non integer objects\") except Exception as E: print(\"Exception occurs during division operation\") finally: del num1 del num2 print(\"Finally clause Executed\") Output The second operand value shouldn't be zero of division operation Finally clause Executed","title":"Exception Handling"},{"location":"python/python_exceptions/#built-in-exceptions","text":"Below are the list of inbuilt exception which occurs at runtime due to logical errors Exception Reason for exception Assertion Error occurs during the failure of assert statements Attribute Error occurs during the failure of attribute assignment EOF Error occurs when the input function reaches the end of file condition Floatingpoint Error occurs during the failure of floating point operations GeneratorExit Error occurs if the closed method is called in generator Import Error occurs if the imported module is not found KeyError Error occurs during the failure of founding key in given dict KeyInterrupt Error occurs if the console receives delete or ctrl+c commands Memory Error occurs if the memory exceeds the limit Name Error occurs if the variable is not available in the given scope NotImplemented Error occurs if the class not implemented the abstract methods OS Error occurs during the system related failures Overflow Error occurs during the failure to represent large arithmetic operation Reference Error occurs during the garbage collected referent access by a week reference proxy Runtime Error occurs during the occurrence of unidentified exception Stopiteration Error occurs when the iterator function not having any other items to iterate Syntax Error occurs during the error in program syntax Indentation Error occurs due to incorrect indentation Tab Error occurs due to inconsistent tabs or spaces in indentation System Error occurs due to the internal error faced by interpreter System Exit occurs due to sys.exit function Type Error occurs due to the incorrect object type Unboundlocal Error occurs due to the missing of value for the given variable in a function Unicode Error occurs due to the error in unicode related encoding and decoding UnicodeEncode Error occurs due to the error in unicode related encoding UnicodeDecode Error occurs due to the error in unicode related decoding UnicodeTranslate Error occurs due to the error in unicode related translating Value Error occurs due to the improper value for the passed arguments with correct type ZeroDivision Error occurs due to zero value in division or modulo operation's second operand","title":"Built-In  Exceptions"},{"location":"python/python_exceptions/#try-and-except-clause","text":"The major functionality which can raise exception should be declare inside try statement and the code which handles the raised exception should be declare inside the except clause like the below sample program #Exception Handling num1 = 10 num2 = 0 try: result = num1//num2 except: print(\"Exception occurs during division operation\") Output Exception during division operation","title":"Try and Except clause"},{"location":"python/python_exceptions/#try-and-multiple-except-clause","text":"Its not a good practice the exception in very general way like the above program. We should handle the exception based on the type of exception raises like the below programs Program 1: Handling Zero Division Exception #Handling Zero Division Exception num1 = 10 num2 = 0 try: result = num1//num2 except ZeroDivisionError: print(\"The second operand value shouldn't be zero of division operation\") except TypeError: print(\"The division operation cannot be perform for non integer type objects\") except Exception as E: print(\"Exception occurs during division operation\") Output The second operand value shouldn't be zero of division operation Program 2: Handling invalid type Exception #Handling invalid type Exception num1 = 10 num2 = \"0\" try: result = num1//num2 except ZeroDivisionError: print(\"The second operand value shouldn't be zero of division operation\") except TypeError: print(\"The division operation cannot be perform for non integer objects\") except Exception as E: print(\"Exception occurs during division operation\") Output The division operation cannot be perform for non integer objects Program 3: Handling General Exceptions #Handling general Exception num1 = 10 try: result = num1//num2 except ZeroDivisionError: print(\"The second operand value shouldn't be zero of division operation\") except TypeError: print(\"The division operation cannot be perform for non integer objects\") except Exception as E: print(\"Exception occurs during division operation\") Output Exception occurs during division operation","title":"Try and Multiple Except clause"},{"location":"python/python_exceptions/#try-except-and-else-clause","text":"After the successful execution of try statement, if we want to execute some other code that can be handle in else clause. If no exception occurs in execution, else clause block executes by the interpreter #Else clause num1 = 10 num2 = 5 try: result = num1//num2 except ZeroDivisionError: print(\"The second operand value shouldn't be zero of division operation\") except TypeError: print(\"The division operation cannot be perform for non integer objects\") except Exception as E: print(\"Exception occurs during division operation\") else: print(result) Output 2","title":"Try, Except and Else clause"},{"location":"python/python_exceptions/#try-except-and-finally-clause","text":"Finally clause executes for both successful and exceptional cases. Usually it uses for cleanup the resources like the below program Program 1: Finally clause - Successful scenario #Finally clause num1 = 10 num2 = 2 try: result = num1//num2 print(result) except ZeroDivisionError: print(\"The second operand value shouldn't be zero of division operation\") except TypeError: print(\"The division operation cannot be perform for non integer objects\") except Exception as E: print(\"Exception occurs during division operation\") finally: del num1 del num2 print(\"Finally clause Executed\") Output 5 Finally clause Executed Program 2: Finally clause - Exception scenario #Finally clause num1 = 10 num2 = 0 try: result = num1//num2 print(result) except ZeroDivisionError: print(\"The second operand value shouldn't be zero of division operation\") except TypeError: print(\"The division operation cannot be perform for non integer objects\") except Exception as E: print(\"Exception occurs during division operation\") finally: del num1 del num2 print(\"Finally clause Executed\") Output The second operand value shouldn't be zero of division operation Finally clause Executed","title":"Try, Except and Finally clause"},{"location":"python/python_generators/","text":"Generators helps to simplify the iterator concepts in python. The implementation of iter and next method is not required to build the traversal object in generator. With the help of yield keyword instead of return keyword. we can build iterable objects Generators The same ten multiples concepts can be implement in generators with few lines of code like the below example. #Python Generators def TenMultipler(multiple, max_limit): start = multiple * 10 for num in range(start, max_limit+1, start): yield num for each in TenMultipler(2, 100): print(each) Output 20 40 60 80 100 Generator Expression Generator Expressions are awesome feature like list comprehension, we can build generator for the entire list without user-defined function. The generator expressions are more memory efficient since it will generate item only when requested but list comprehension generates the entire items during conversion itself input_list = [1, 2, 3, 4, 5] #Generator Expression result = ( each*10 for each in input_list ) print(\"Output result from generator expression: \") #Generator item needs to generate one by one for each in result: print(each) #list comprehension result = [ each*10 for each in input_list ] print(\"Output result from list comprehension: \") #No need to generate one by one like generator expression print(result) output Output result from generator expression: 10 20 30 40 50 Output result from list comprehension: [10, 20, 30, 40, 50]","title":"Python Generators"},{"location":"python/python_generators/#generators","text":"The same ten multiples concepts can be implement in generators with few lines of code like the below example. #Python Generators def TenMultipler(multiple, max_limit): start = multiple * 10 for num in range(start, max_limit+1, start): yield num for each in TenMultipler(2, 100): print(each) Output 20 40 60 80 100","title":"Generators"},{"location":"python/python_generators/#generator-expression","text":"Generator Expressions are awesome feature like list comprehension, we can build generator for the entire list without user-defined function. The generator expressions are more memory efficient since it will generate item only when requested but list comprehension generates the entire items during conversion itself input_list = [1, 2, 3, 4, 5] #Generator Expression result = ( each*10 for each in input_list ) print(\"Output result from generator expression: \") #Generator item needs to generate one by one for each in result: print(each) #list comprehension result = [ each*10 for each in input_list ] print(\"Output result from list comprehension: \") #No need to generate one by one like generator expression print(result) output Output result from generator expression: 10 20 30 40 50 Output result from list comprehension: [10, 20, 30, 40, 50]","title":"Generator Expression"},{"location":"python/python_inheritance/","text":"Inheritance is one of the powerful feature in OOPS. Through which we can inherit the properties from another class, so that the code can be reused without written of same code again and again Types of Inheritance OOPS is a very famous and popular programming paradigm Single Inheritance Multiple Inheritance Multilevel Inheritance Hierarchical Inheritance Hybrid Inheritance Single Inheritance In single inheritance, child class inherits from only one parent class. By calling the parent class name in child class, single inheritance can be implemented easily in python #Parent class class Fruit: def fruits_benefits(self): print(\"I am parent class : Fruits Benefits\") #Child class class Apple(Fruit): def apple_benefits(self): print(\"I am child class : Apple Benefits\") #Object creation apple_fruit = Apple() #Access the parent method apple_fruit.fruits_benefits() #Access the child method apple_fruit.apple_benefits() Output I am parent class : Fruits Benefits I am child class : Apple Benefits Multiple Inheritance In multiple inheritance, child class inherits from only more than one parent class. By calling the multiple parent class name in child class, multiple inheritance can be implemented #Parent class - 1 class Fruit: def fruits_benefits(self): print(\"I am parent class 1 : Fruits Benefits\") #Parent class - 2 class Flower: def flower_benefits(self): print(\"I am parent class 2 : Flower Benefits\") #Child class class Apple(Fruit, Flower): def apple_benefits(self): print(\"I am child class : Apple Benefits\") #Object creation apple_fruit = Apple() #Access the parent method apple_fruit.fruits_benefits() #Access the parent method apple_fruit.flower_benefits() #Access the child method apple_fruit.apple_benefits() Output I am parent class 1 : Fruits Benefits I am parent class 2 : Flower Benefits I am child class : Apple Benefits Multilevel Inheritance In multilevel inheritance, grandchild class inherits from child class which inherits from parent class in python #Parent class class Fruit: def fruits_benefits(self): print(\"I am parent class : Fruits Benefits\") #Child class class Apple(Fruit): def apple_benefits(self): print(\"I am child class : Apple Benefits\") #Grandchild class class Breakfast(Apple): def breakfast_benefits(self): print(\"I am grandchild class : Breakfast Benefits\") #Object creation breakfast = Breakfast() #Access the parent method breakfast.fruits_benefits() #Access the child method breakfast.apple_benefits() #Access the grandchild method breakfast.breakfast_benefits() Output I am parent class : Fruits Benefits I am child class : Apple Benefits I am grandchild class : Breakfast Benefits Hierarchical Inheritance In Hierarchical inheritance, a parent class have multiple child classes #Parent class class Fruit: def fruits_benefits(self): print(\"I am parent class : Fruits Benefits\") #Child class 1 class Apple(Fruit): def apple_benefits(self): print(\"I am child class 1 : Apple Benefits\") #Child class 2 class Orange(Fruit): def orange_benefits(self): print(\"I am child class 2 : Orange Benefits\") #Object creation 1 apple = Apple() apple.fruits_benefits() apple.apple_benefits() #Object creation 2 orange = Orange() orange.fruits_benefits() orange.orange_benefits() Output I am parent class : Fruits Benefits I am child class 1 : Apple Benefits I am parent class : Fruits Benefits I am child class 2 : Orange Benefits Hybrid Inheritance Its a combination of two or more above mentioned types of inheritance Multiple and multilevel inheritance combination is an example for hybrid inheritance #Parent class class Fruit: def fruits_benefits(self): print(\"I am parent class : Fruits Benefits\") #Child class 1 class Apple(Fruit): def apple_benefits(self): print(\"I am child class 1 : Apple Benefits\") #Grandchild class class Breakfast(Apple): def breakfast_benefits(self): print(\"I am grand child class 1 : Breakfast Benefits\") #Child class 2 class Orange(Fruit): def orange_benefits(self): print(\"I am child class 2 : Orange Benefits\") #Grandchild class class Lunch(Orange): def lunch_benefits(self): print(\"I am grand child class 1: Lunch Benefits\") #Object creation 1 breakfast = Breakfast() breakfast.fruits_benefits() breakfast.apple_benefits() breakfast.breakfast_benefits() #Object creation 2 lunch = Lunch() lunch.fruits_benefits() lunch.orange_benefits() lunch.lunch_benefits() Output I am parent class : Fruits Benefits I am child class 1 : Apple Benefits I am grand child class 1 : Breakfast Benefits I am parent class : Fruits Benefits I am child class 2 : Orange Benefits I am grand child class 1: Lunch Benefits","title":"Python Inheritance"},{"location":"python/python_inheritance/#types-of-inheritance","text":"OOPS is a very famous and popular programming paradigm Single Inheritance Multiple Inheritance Multilevel Inheritance Hierarchical Inheritance Hybrid Inheritance","title":"Types of Inheritance"},{"location":"python/python_inheritance/#single-inheritance","text":"In single inheritance, child class inherits from only one parent class. By calling the parent class name in child class, single inheritance can be implemented easily in python #Parent class class Fruit: def fruits_benefits(self): print(\"I am parent class : Fruits Benefits\") #Child class class Apple(Fruit): def apple_benefits(self): print(\"I am child class : Apple Benefits\") #Object creation apple_fruit = Apple() #Access the parent method apple_fruit.fruits_benefits() #Access the child method apple_fruit.apple_benefits() Output I am parent class : Fruits Benefits I am child class : Apple Benefits","title":"Single Inheritance"},{"location":"python/python_inheritance/#multiple-inheritance","text":"In multiple inheritance, child class inherits from only more than one parent class. By calling the multiple parent class name in child class, multiple inheritance can be implemented #Parent class - 1 class Fruit: def fruits_benefits(self): print(\"I am parent class 1 : Fruits Benefits\") #Parent class - 2 class Flower: def flower_benefits(self): print(\"I am parent class 2 : Flower Benefits\") #Child class class Apple(Fruit, Flower): def apple_benefits(self): print(\"I am child class : Apple Benefits\") #Object creation apple_fruit = Apple() #Access the parent method apple_fruit.fruits_benefits() #Access the parent method apple_fruit.flower_benefits() #Access the child method apple_fruit.apple_benefits() Output I am parent class 1 : Fruits Benefits I am parent class 2 : Flower Benefits I am child class : Apple Benefits","title":"Multiple Inheritance"},{"location":"python/python_inheritance/#multilevel-inheritance","text":"In multilevel inheritance, grandchild class inherits from child class which inherits from parent class in python #Parent class class Fruit: def fruits_benefits(self): print(\"I am parent class : Fruits Benefits\") #Child class class Apple(Fruit): def apple_benefits(self): print(\"I am child class : Apple Benefits\") #Grandchild class class Breakfast(Apple): def breakfast_benefits(self): print(\"I am grandchild class : Breakfast Benefits\") #Object creation breakfast = Breakfast() #Access the parent method breakfast.fruits_benefits() #Access the child method breakfast.apple_benefits() #Access the grandchild method breakfast.breakfast_benefits() Output I am parent class : Fruits Benefits I am child class : Apple Benefits I am grandchild class : Breakfast Benefits","title":"Multilevel Inheritance"},{"location":"python/python_inheritance/#hierarchical-inheritance","text":"In Hierarchical inheritance, a parent class have multiple child classes #Parent class class Fruit: def fruits_benefits(self): print(\"I am parent class : Fruits Benefits\") #Child class 1 class Apple(Fruit): def apple_benefits(self): print(\"I am child class 1 : Apple Benefits\") #Child class 2 class Orange(Fruit): def orange_benefits(self): print(\"I am child class 2 : Orange Benefits\") #Object creation 1 apple = Apple() apple.fruits_benefits() apple.apple_benefits() #Object creation 2 orange = Orange() orange.fruits_benefits() orange.orange_benefits() Output I am parent class : Fruits Benefits I am child class 1 : Apple Benefits I am parent class : Fruits Benefits I am child class 2 : Orange Benefits","title":"Hierarchical Inheritance"},{"location":"python/python_inheritance/#hybrid-inheritance","text":"Its a combination of two or more above mentioned types of inheritance Multiple and multilevel inheritance combination is an example for hybrid inheritance #Parent class class Fruit: def fruits_benefits(self): print(\"I am parent class : Fruits Benefits\") #Child class 1 class Apple(Fruit): def apple_benefits(self): print(\"I am child class 1 : Apple Benefits\") #Grandchild class class Breakfast(Apple): def breakfast_benefits(self): print(\"I am grand child class 1 : Breakfast Benefits\") #Child class 2 class Orange(Fruit): def orange_benefits(self): print(\"I am child class 2 : Orange Benefits\") #Grandchild class class Lunch(Orange): def lunch_benefits(self): print(\"I am grand child class 1: Lunch Benefits\") #Object creation 1 breakfast = Breakfast() breakfast.fruits_benefits() breakfast.apple_benefits() breakfast.breakfast_benefits() #Object creation 2 lunch = Lunch() lunch.fruits_benefits() lunch.orange_benefits() lunch.lunch_benefits() Output I am parent class : Fruits Benefits I am child class 1 : Apple Benefits I am grand child class 1 : Breakfast Benefits I am parent class : Fruits Benefits I am child class 2 : Orange Benefits I am grand child class 1: Lunch Benefits","title":"Hybrid Inheritance"},{"location":"python/python_iterators/","text":"Iterators helps to iterate the iterable objects like list, tuple, set and dict in python. We can create custom iterator for the python functions Iterators Two function - iter and next helps to achieve the iterate over the given data in python like the below example num_list = [10, 20, 30, 40, 50] #Make the num list iterable iter_num_list = iter(num_list) while num_list: try: print(next(iter_num_list)) #No more elements raises stop iteration exception except StopIteration: break Output 10 20 30 40 50 Custom Iterators Implementation of custom iterators for our function is very easier. With the help of __iter__ and __next__ methods, we can build the custom iterators like the below example #Custom Iterator class TenMultipler: def __init__(self, multiple, max_limit): self.multiple = multiple self.max_limit = max_limit def __iter__(self): self.start = self.multiple return self def __next__(self): result = self.multiple * 10 if result <= self.max_limit: self.multiple = self.start + self.multiple return result else: raise StopIteration tenMultipler = TenMultipler(2, 100) iter_tenMultipler = iter(tenMultipler) while iter_tenMultipler: try: print(next(iter_tenMultipler)) except: print(\"Max limit reached - Iteration stopped\") break Output 20 40 60 80 100 Max limit reached - Iteration stopped","title":"Python Iterators"},{"location":"python/python_iterators/#iterators","text":"Two function - iter and next helps to achieve the iterate over the given data in python like the below example num_list = [10, 20, 30, 40, 50] #Make the num list iterable iter_num_list = iter(num_list) while num_list: try: print(next(iter_num_list)) #No more elements raises stop iteration exception except StopIteration: break Output 10 20 30 40 50","title":"Iterators"},{"location":"python/python_iterators/#custom-iterators","text":"Implementation of custom iterators for our function is very easier. With the help of __iter__ and __next__ methods, we can build the custom iterators like the below example #Custom Iterator class TenMultipler: def __init__(self, multiple, max_limit): self.multiple = multiple self.max_limit = max_limit def __iter__(self): self.start = self.multiple return self def __next__(self): result = self.multiple * 10 if result <= self.max_limit: self.multiple = self.start + self.multiple return result else: raise StopIteration tenMultipler = TenMultipler(2, 100) iter_tenMultipler = iter(tenMultipler) while iter_tenMultipler: try: print(next(iter_tenMultipler)) except: print(\"Max limit reached - Iteration stopped\") break Output 20 40 60 80 100 Max limit reached - Iteration stopped","title":"Custom Iterators"},{"location":"python/python_keywords/","text":"keywords which should not used as any identifier, they are already reserved for special purposes by python interpreter Below are the list of keywords in python (they are case - sensitive) List of Keywords False await else import pass None break except in raise True class finally is return and continue for lambda try as def from nonlocal while assert del global not with async elif if or yield IsKeyword Method This function helps to check whether the given name is keyword or not #IsKeyword Method import keyword #Check with keywords in python print(\"'IS' a keyword in python? : {}\".format(keyword.iskeyword(\"is\"))) print(\"'IN' a keyword in python? : {}\".format(keyword.iskeyword(\"in\"))) #Check with Non-keywords in python print(\"'Rathna' a keyword in python? : {}\".format(keyword.iskeyword(\"Rathna\"))) print(\"'Schools' a keyword in python? : {}\".format(keyword.iskeyword(\"Schools\"))) Kwlist Method Kwlist method helps to return the list of keywords available in python #kwlist Function import keyword #Check with keywords in python print(keyword.kwlist) Output ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']","title":"Python Keywords"},{"location":"python/python_keywords/#list-of-keywords","text":"False await else import pass None break except in raise True class finally is return and continue for lambda try as def from nonlocal while assert del global not with async elif if or yield","title":"List of Keywords"},{"location":"python/python_keywords/#iskeyword-method","text":"This function helps to check whether the given name is keyword or not #IsKeyword Method import keyword #Check with keywords in python print(\"'IS' a keyword in python? : {}\".format(keyword.iskeyword(\"is\"))) print(\"'IN' a keyword in python? : {}\".format(keyword.iskeyword(\"in\"))) #Check with Non-keywords in python print(\"'Rathna' a keyword in python? : {}\".format(keyword.iskeyword(\"Rathna\"))) print(\"'Schools' a keyword in python? : {}\".format(keyword.iskeyword(\"Schools\")))","title":"IsKeyword Method"},{"location":"python/python_keywords/#kwlist-method","text":"Kwlist method helps to return the list of keywords available in python #kwlist Function import keyword #Check with keywords in python print(keyword.kwlist) Output ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']","title":"Kwlist Method"},{"location":"python/python_lists/","text":"Lists are used to store multiple items in a single variable. They are just like dynamically sized arrays, declared in other languages (vector in C++ and ArrayList in Java). Lists need not be homogeneous always which makes it the most powerful tool in Python List Creation List created by declare all the items inside the square brackets [] #List Creation languages = [\"Python\", \"Java\", \"Javascript\"] print(type(languages)) #Multiple data types can store in list user_details = [1, \"PYTHON\", \"99.0\", [\"Jan\", \"Feb\"]] print(user_details) Output <class 'list'> [1, 'PYTHON', '99.0', ['Jan', 'Feb']] List Reading List items can be read with the help of positive or negative index of that corresponding position \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1 Every item in the list have both positive and negative index like the above table #List Reading month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"] #Reading the first item of the list print(month_list[0]) print(month_list[-6]) #Reading the second item of the list print(month_list[1]) print(month_list[-5]) #Reading the last item of the list print(month_list[5]) print(month_list[-1]) Output Jan Jan Feb Feb Jun Jun List Update List are mutable data types in python, so we can perform the update operation. No need to create new object for modification #List Update month_list = [\"Jan\", \"Dec\", \"Mar\", \"Apr\", \"May\", \"Jun\"] print(id(month_list)) #Update using index of the item month_list[1] = \"Feb\" print(month_list) print(id(month_list)) Output 140324018130432 ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'] 140324018130432 List Deletion Since list are mutable data types in python, we can perform the delete operation without delete the entire object and recreate for the few deletion #List Deletion month_list = [\"Jan\", \"Dec\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"] print(id(month_list)) #Deletion using index of the item month_list.remove(\"Dec\") print(month_list) print(id(month_list)) Output 139779868761664 ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'] 139779868761664 Since list is immutable data type, id of the list object not changed even after deletion List Slicing List slicing helps to return the required objects from the given list ListName(start Index: stop Index: step Value (optional)] start Index Not declare means, first value index consider by python stop Index Not declare means, last value index consider by python Read a object with the help of positive and negative index value \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1 #List Slicing month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"] #Print the first two items print(month_list[0:2]) print(month_list[-6:2]) print(month_list[:2]) #Print the middle two items print(month_list[2:4]) print(month_list[-4:4]) #Print the last two items print(month_list[4:6]) print(month_list[-2:6]) print(month_list[4:]) Output ['Jan', 'Feb'] ['Jan', 'Feb'] ['Jan', 'Feb'] ['Mar', 'Apr'] ['Mar', 'Apr'] ['May', 'Jun'] ['May', 'Jun'] ['May', 'Jun']","title":"Python Lists"},{"location":"python/python_lists/#list-creation","text":"List created by declare all the items inside the square brackets [] #List Creation languages = [\"Python\", \"Java\", \"Javascript\"] print(type(languages)) #Multiple data types can store in list user_details = [1, \"PYTHON\", \"99.0\", [\"Jan\", \"Feb\"]] print(user_details) Output <class 'list'> [1, 'PYTHON', '99.0', ['Jan', 'Feb']]","title":"List Creation"},{"location":"python/python_lists/#list-reading","text":"List items can be read with the help of positive or negative index of that corresponding position \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1 Every item in the list have both positive and negative index like the above table #List Reading month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"] #Reading the first item of the list print(month_list[0]) print(month_list[-6]) #Reading the second item of the list print(month_list[1]) print(month_list[-5]) #Reading the last item of the list print(month_list[5]) print(month_list[-1]) Output Jan Jan Feb Feb Jun Jun","title":"List Reading"},{"location":"python/python_lists/#list-update","text":"List are mutable data types in python, so we can perform the update operation. No need to create new object for modification #List Update month_list = [\"Jan\", \"Dec\", \"Mar\", \"Apr\", \"May\", \"Jun\"] print(id(month_list)) #Update using index of the item month_list[1] = \"Feb\" print(month_list) print(id(month_list)) Output 140324018130432 ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'] 140324018130432","title":"List Update"},{"location":"python/python_lists/#list-deletion","text":"Since list are mutable data types in python, we can perform the delete operation without delete the entire object and recreate for the few deletion #List Deletion month_list = [\"Jan\", \"Dec\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"] print(id(month_list)) #Deletion using index of the item month_list.remove(\"Dec\") print(month_list) print(id(month_list)) Output 139779868761664 ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'] 139779868761664 Since list is immutable data type, id of the list object not changed even after deletion","title":"List Deletion"},{"location":"python/python_lists/#list-slicing","text":"List slicing helps to return the required objects from the given list ListName(start Index: stop Index: step Value (optional)] start Index Not declare means, first value index consider by python stop Index Not declare means, last value index consider by python Read a object with the help of positive and negative index value \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1 #List Slicing month_list = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"] #Print the first two items print(month_list[0:2]) print(month_list[-6:2]) print(month_list[:2]) #Print the middle two items print(month_list[2:4]) print(month_list[-4:4]) #Print the last two items print(month_list[4:6]) print(month_list[-2:6]) print(month_list[4:]) Output ['Jan', 'Feb'] ['Jan', 'Feb'] ['Jan', 'Feb'] ['Mar', 'Apr'] ['Mar', 'Apr'] ['May', 'Jun'] ['May', 'Jun'] ['May', 'Jun']","title":"List Slicing"},{"location":"python/python_numbers/","text":"As mentioned in Python Data types section, Python provides the support for integers, floating and complex numbers. In this section, Lets learn the Math function and type conversion methods Round Function Round function used to round the float number to nearest whole number #Round Function #Nearest whole number is 5 print( round(5.1) ) #Nearest whole number is 6 print( round(5.8) ) #Nearest even number considers for 0.5 cases print( round(6.5) ) print( round(7.5) ) #Rounding with second argument print( round(21.7777777777, 3) ) Output 5 6 6 8 21.778 Power Function Power function is similar to ** operator which we have learned in arithmetic operator section #Power Function #Below power function similar to 2*2*2*2*2 print( pow(2, 5) ) #Below power function similar to (2*2*2*2*2)%3 print( pow(2, 5, 3) ) Output 32 2 Absolute Function Absolute function helps to convert negative number into positive number #Absolute Function #Convert negative number to positive number print( abs(-100) ) Output 100 Type Conversion Types conversion helps to covert the value from one data type to another data type Two types of Type conversion in python: Implicit Type Conversion Explicit Type Conversion Implicit Type Conversion Python automatically converts the value from one data type to another #Implicit Type Conversion num1 = 5 num2 = 3.5 result = num1 + num2 print(type(result)) print(result) Output <class 'float'> 8.5 Explicit Type Conversion In some cases, user requires to change the type of the data explicitly before operation #Explicit Type Conversion num1 = 50 num2 = \"50\" result = num1 + num2 print(result) Output Traceback (most recent call last): File \"<string>\", line 5, in <module> TypeError: unsupported operand type(s) for +: 'int' and 'str' Explicit conversion helps to overcome the type error #Explicit Type Conversion num1 = 50 num2 = int(\"50\") result = num1 + num2 print(result) Output 100","title":"Python Numbers"},{"location":"python/python_numbers/#round-function","text":"Round function used to round the float number to nearest whole number #Round Function #Nearest whole number is 5 print( round(5.1) ) #Nearest whole number is 6 print( round(5.8) ) #Nearest even number considers for 0.5 cases print( round(6.5) ) print( round(7.5) ) #Rounding with second argument print( round(21.7777777777, 3) ) Output 5 6 6 8 21.778","title":"Round Function"},{"location":"python/python_numbers/#power-function","text":"Power function is similar to ** operator which we have learned in arithmetic operator section #Power Function #Below power function similar to 2*2*2*2*2 print( pow(2, 5) ) #Below power function similar to (2*2*2*2*2)%3 print( pow(2, 5, 3) ) Output 32 2","title":"Power Function"},{"location":"python/python_numbers/#absolute-function","text":"Absolute function helps to convert negative number into positive number #Absolute Function #Convert negative number to positive number print( abs(-100) ) Output 100","title":"Absolute Function"},{"location":"python/python_numbers/#type-conversion","text":"Types conversion helps to covert the value from one data type to another data type Two types of Type conversion in python: Implicit Type Conversion Explicit Type Conversion Implicit Type Conversion Python automatically converts the value from one data type to another #Implicit Type Conversion num1 = 5 num2 = 3.5 result = num1 + num2 print(type(result)) print(result) Output <class 'float'> 8.5 Explicit Type Conversion In some cases, user requires to change the type of the data explicitly before operation #Explicit Type Conversion num1 = 50 num2 = \"50\" result = num1 + num2 print(result) Output Traceback (most recent call last): File \"<string>\", line 5, in <module> TypeError: unsupported operand type(s) for +: 'int' and 'str' Explicit conversion helps to overcome the type error #Explicit Type Conversion num1 = 50 num2 = int(\"50\") result = num1 + num2 print(result) Output 100","title":"Type Conversion"},{"location":"python/python_operators/","text":"Operators are used to perform various mathematical operations on the data value. Operators are used to perform various mathematical operations on the data value Types of Operators 1. Arithmetic operators 2. Comparison operators 3. Logical operators 4. Identity operators 5. Membership operators 6. Bitwise operators Arithmetic operators Arithmetic operators are used to perform simple arithmetic operations over the operands #Addition Operation add_result = 10 + 20 print(\"Addition Result : {}\".format(add_result)) #Subtraction Operation sub_result = 100 - 50 print(\"Subtraction Result : {}\".format(sub_result)) #Multiplication Operation multi_result = 10 * 20 print(\"Multiplication Result : {}\".format(multi_result)) #Division Operation (Decimal Value) div_result = 25 / 10 print(\"Division Result : {}\".format(div_result)) #Floor Division (Nearest Whole Number) floor_result = 25//10 print(\"Floor Result : {}\".format(floor_result)) #Modulus Operation mod_result = 25%10 print(\"Modulus Result : {}\".format(mod_result)) #Exponential Operation (2*2*2*2*2) exp_result = 2 ** 5 print(\"Exponential Result : {}\".format(exp_result)) Output Addition Result : 30 Subtraction Result : 50 Multiplication Result : 200 Division Result : 2.5 Floor Result : 2 Modulus Result : 5 Exponential Result : 32 Comparison operators Comparison operators are used to check for relations between the operands #Equal Operator num1, num2 = 50, 50 if num1==num2: print(\"Equal\") #Not Equal Operator num1, num2 = 50, 100 if num1!=num2: print(\"Not Equal\") #Greater than Operator num1, num2 = 100, 50 if num1>num2: print(\"Greater\") #Greater than Operator num1, num2 = 50, 100 if num1<num2: print(\"Lesser\") #Greater than or Equal to num1, num2 = 50, 50 if num1>=num2: print(\"Greater than or Equal to\") #Lesser than or Equal to num1, num2 = 50, 50 if num1<=num2: print(\"Lesser than or Equal to\") Output Equal Not Equal Greater Lesser Greater than or Equal to Lesser than or Equal to Logical operators Logical Operators are used to check conditional expression. We can use these operators in conditional and looping statement for evaluation #AND - Returns True If both conditions are True num = 50 if num>10 and num<100: print(True) #OR - Returns True If any one of the conditions is True num = 50 if num>10 or num<30: print(True) #NOT - Returns opposite of the result num = 50 if not(num>100): print(True) Output True True True Identity operators Identity operators are used to compare the object's memory location == Operator usually compare the value of given objects is operator compare the memory location of given objects. It returns True if both variables are the same object num_list1 = [1, 2, 3] num_list2 = [1, 2, 3] num_list3 = num_list1 #Both have same data, So result is True print(num_list1 == num_list2) #Both have same data, So result is True print(num_list1 == num_list3) #Both are different object, So result is False print(num_list1 is num_list2) #Both are same object, So result is True print(num_list1 is num_list3) Output True True False True Bitwise operators Bitwise operators are used to perform operations bit by bit Bitwise AND operator num1 = 3 num2 = 5 #BITWISE AND Operator returns 1 if both the bits are 1 print( num1&num2 ) Output 1 The result is 1, because 3 is equal to 0011 in binary and 5 is equal to 0101 in binary Now compare each bit between 3 and 5, only last bit are 1 for both, so that alone returns 1 in final result. Hence, 0001 decimal value is 1, that is get printed in final output 0011 = 3 0101 = 5 ---------- 0001 = 1 Bitwise OR operator num1 = 3 num2 = 5 #BITWISE OR Operator returns 1 if anyone of two bits are 1 print( num1 | num2 ) Output 1 The result is 7, because 3 is equal to 0011 in binary and 5 is equal to 0101 in binary Now compare each bit between 3 and 5, the last three having latest one of two bits is 1, so that three bits returns 1. Hence, 0111 decimal value is 7, that is get printed in final output 0011 = 3 0101 = 5 ---------- 0111 = 7 Bitwise XOR operator num1 = 3 num2 = 5 #BITWISE XOR Operator returns 1 if both bit are not equal print( num1 ^ num2 ) Output 6 The result is 6, because 3 is equal to 0011 in binary and 5 is equal to 0101 in binary Now compare each bit between 3 and 5, only 2nd and 3rd third sets having one of the bit is 1 and other is 0, so that two bits returns 1. Hence, 0111 decimal value is 6, that is get printed in final output 0011 = 3 0101 = 5 ---------- 0110 = 6 Bitwise NOT operator num = 3 #BITWISE NOT Operator returns 1's compliment of the number print( ~num ) Output -4 The result is -4, because 3 is equal to 0011 in binary First it add last bit 1+1 = 10 in binary (0 is result and 1 is carry) Second it add second bit 1 with carry 1 which means 1+1 = 10 in binary (0 is result and 1 is carry) Third it add third bit 0 with carry 1 which means 1+0=0 in binary (no carry) Fourth it only have one bit 0 and no carry, so result in 0 Since its a 1's compliment we should have - value for the output decimal, so it gives -0100 as -4 in decimal output. 0011 = 3 - 1 -------------- - 0100 = -4 Left shift operator num = 3 #LEFT SHIFT - Shifting Bit to Leftmost print( num<<2 ) Output 12 The result is 12, since the bits are pushing from left to right (2 places movement since we gave <<2 ) 0011 = 3 <<2 ------------ 1100 = 12 Right shift operator num = 8 #RIGHT SHIFT - Shifting Bit to Rightmost print( num>>3 ) Output 1 The result is 1, since the bits are pushing from right to left (3 places movement since we gave <<3) 1000 = 8 >>3 ------------- 0001 = 1","title":"Python Operators"},{"location":"python/python_operators/#types-of-operators","text":"1. Arithmetic operators 2. Comparison operators 3. Logical operators 4. Identity operators 5. Membership operators 6. Bitwise operators","title":"Types of Operators"},{"location":"python/python_operators/#arithmetic-operators","text":"Arithmetic operators are used to perform simple arithmetic operations over the operands #Addition Operation add_result = 10 + 20 print(\"Addition Result : {}\".format(add_result)) #Subtraction Operation sub_result = 100 - 50 print(\"Subtraction Result : {}\".format(sub_result)) #Multiplication Operation multi_result = 10 * 20 print(\"Multiplication Result : {}\".format(multi_result)) #Division Operation (Decimal Value) div_result = 25 / 10 print(\"Division Result : {}\".format(div_result)) #Floor Division (Nearest Whole Number) floor_result = 25//10 print(\"Floor Result : {}\".format(floor_result)) #Modulus Operation mod_result = 25%10 print(\"Modulus Result : {}\".format(mod_result)) #Exponential Operation (2*2*2*2*2) exp_result = 2 ** 5 print(\"Exponential Result : {}\".format(exp_result)) Output Addition Result : 30 Subtraction Result : 50 Multiplication Result : 200 Division Result : 2.5 Floor Result : 2 Modulus Result : 5 Exponential Result : 32","title":"Arithmetic operators"},{"location":"python/python_operators/#comparison-operators","text":"Comparison operators are used to check for relations between the operands #Equal Operator num1, num2 = 50, 50 if num1==num2: print(\"Equal\") #Not Equal Operator num1, num2 = 50, 100 if num1!=num2: print(\"Not Equal\") #Greater than Operator num1, num2 = 100, 50 if num1>num2: print(\"Greater\") #Greater than Operator num1, num2 = 50, 100 if num1<num2: print(\"Lesser\") #Greater than or Equal to num1, num2 = 50, 50 if num1>=num2: print(\"Greater than or Equal to\") #Lesser than or Equal to num1, num2 = 50, 50 if num1<=num2: print(\"Lesser than or Equal to\") Output Equal Not Equal Greater Lesser Greater than or Equal to Lesser than or Equal to","title":"Comparison operators"},{"location":"python/python_operators/#logical-operators","text":"Logical Operators are used to check conditional expression. We can use these operators in conditional and looping statement for evaluation #AND - Returns True If both conditions are True num = 50 if num>10 and num<100: print(True) #OR - Returns True If any one of the conditions is True num = 50 if num>10 or num<30: print(True) #NOT - Returns opposite of the result num = 50 if not(num>100): print(True) Output True True True","title":"Logical operators"},{"location":"python/python_operators/#identity-operators","text":"Identity operators are used to compare the object's memory location == Operator usually compare the value of given objects is operator compare the memory location of given objects. It returns True if both variables are the same object num_list1 = [1, 2, 3] num_list2 = [1, 2, 3] num_list3 = num_list1 #Both have same data, So result is True print(num_list1 == num_list2) #Both have same data, So result is True print(num_list1 == num_list3) #Both are different object, So result is False print(num_list1 is num_list2) #Both are same object, So result is True print(num_list1 is num_list3) Output True True False True","title":"Identity operators"},{"location":"python/python_operators/#bitwise-operators","text":"Bitwise operators are used to perform operations bit by bit Bitwise AND operator num1 = 3 num2 = 5 #BITWISE AND Operator returns 1 if both the bits are 1 print( num1&num2 ) Output 1 The result is 1, because 3 is equal to 0011 in binary and 5 is equal to 0101 in binary Now compare each bit between 3 and 5, only last bit are 1 for both, so that alone returns 1 in final result. Hence, 0001 decimal value is 1, that is get printed in final output 0011 = 3 0101 = 5 ---------- 0001 = 1 Bitwise OR operator num1 = 3 num2 = 5 #BITWISE OR Operator returns 1 if anyone of two bits are 1 print( num1 | num2 ) Output 1 The result is 7, because 3 is equal to 0011 in binary and 5 is equal to 0101 in binary Now compare each bit between 3 and 5, the last three having latest one of two bits is 1, so that three bits returns 1. Hence, 0111 decimal value is 7, that is get printed in final output 0011 = 3 0101 = 5 ---------- 0111 = 7 Bitwise XOR operator num1 = 3 num2 = 5 #BITWISE XOR Operator returns 1 if both bit are not equal print( num1 ^ num2 ) Output 6 The result is 6, because 3 is equal to 0011 in binary and 5 is equal to 0101 in binary Now compare each bit between 3 and 5, only 2nd and 3rd third sets having one of the bit is 1 and other is 0, so that two bits returns 1. Hence, 0111 decimal value is 6, that is get printed in final output 0011 = 3 0101 = 5 ---------- 0110 = 6 Bitwise NOT operator num = 3 #BITWISE NOT Operator returns 1's compliment of the number print( ~num ) Output -4 The result is -4, because 3 is equal to 0011 in binary First it add last bit 1+1 = 10 in binary (0 is result and 1 is carry) Second it add second bit 1 with carry 1 which means 1+1 = 10 in binary (0 is result and 1 is carry) Third it add third bit 0 with carry 1 which means 1+0=0 in binary (no carry) Fourth it only have one bit 0 and no carry, so result in 0 Since its a 1's compliment we should have - value for the output decimal, so it gives -0100 as -4 in decimal output. 0011 = 3 - 1 -------------- - 0100 = -4 Left shift operator num = 3 #LEFT SHIFT - Shifting Bit to Leftmost print( num<<2 ) Output 12 The result is 12, since the bits are pushing from left to right (2 places movement since we gave <<2 ) 0011 = 3 <<2 ------------ 1100 = 12 Right shift operator num = 8 #RIGHT SHIFT - Shifting Bit to Rightmost print( num>>3 ) Output 1 The result is 1, since the bits are pushing from right to left (3 places movement since we gave <<3) 1000 = 8 >>3 ------------- 0001 = 1","title":"Bitwise operators"},{"location":"python/python_polymorphism/","text":"Polymorphism plays a vital role in OOPS concepts. Based on the different scenario, same entity behaves in different forms. Class Polymorphism Different class have same method name which behaves based on the object type. In the below example, Car and Auto are the two different classes having same method name number_of_wheels . Based on the object type, the same function gives the different result in output #Class Polymorphism class Car: def number_of_wheels(self): print(\"I have four wheels\") class Auto: def number_of_wheels(self): print(\"I have three wheels\") #Number of wheels function behaves based on the object type for vehicle in (Car(), Auto()): vehicle.number_of_wheels() Output I have four wheels I have three wheels Function Polymorphism Same function which behaves differently for different scenario called as function polymorphism. Below is the simple example in python for function polymorphism #Function polymorphism input_list = [10, 20, 30, 40 ,50] input_string = \"Rathna Schools\" input_dict = { 1:\"python\", 2:\"Java\", 3:\"Javascript\" } #Calling the len function print(len(input_list)) print(len(input_string)) print(len(input_dict)) Output 5 14 3 Operator Overloading In python, operator overloading can be achieved like the below example. '+' operator behaves differently for the different input data types #Operator Overloading # '+' operator perform addition operation for numbers num1 = 10 num2 = 20 print(num1+num2) # '+' operator perform concatenation for strings word1 = \"Rathna \" word2 = \"Schools\" print(word1+word2) Method Overriding Overriding the parent method definition in their child class is called as method overriding. Below is the simple example for method overriding in python. class Shape: def draw(self): pass class Square(Shape): def draw(self): print(\"I am drawing a square\") class Circle(Shape): def draw(self): print(\"I am drawing a circle\") #Similar to class polymorphism but here child class methods override the parent method for shape in (Square(), Circle()): shape.draw() Output I am drawing a square I am drawing a circle Method Overloading In other programming language, we can achieve method overloading by calling the method with different number of arguments. But, its impossible in python which always consider the last definition of the method. class Shape: def draw(self): pass class Circle(Shape): def draw(self): print(\"I am drawing a circe\") def draw(self, radius): print(\"I am drawing a circle with {}cm\".format(radius)) circle = Circle() #This method works without any issues circle.draw(10) #Raises Exception, since second(last) draw method overrides the first(previous) method circle.draw() Output I am drawing a circle with 10cm Traceback (most recent call last): File \"<string>\", line 16, in <module> TypeError: draw() missing 1 required positional argument: 'radius'","title":"Python Polymorphism"},{"location":"python/python_polymorphism/#class-polymorphism","text":"Different class have same method name which behaves based on the object type. In the below example, Car and Auto are the two different classes having same method name number_of_wheels . Based on the object type, the same function gives the different result in output #Class Polymorphism class Car: def number_of_wheels(self): print(\"I have four wheels\") class Auto: def number_of_wheels(self): print(\"I have three wheels\") #Number of wheels function behaves based on the object type for vehicle in (Car(), Auto()): vehicle.number_of_wheels() Output I have four wheels I have three wheels","title":"Class Polymorphism"},{"location":"python/python_polymorphism/#function-polymorphism","text":"Same function which behaves differently for different scenario called as function polymorphism. Below is the simple example in python for function polymorphism #Function polymorphism input_list = [10, 20, 30, 40 ,50] input_string = \"Rathna Schools\" input_dict = { 1:\"python\", 2:\"Java\", 3:\"Javascript\" } #Calling the len function print(len(input_list)) print(len(input_string)) print(len(input_dict)) Output 5 14 3","title":"Function Polymorphism"},{"location":"python/python_polymorphism/#operator-overloading","text":"In python, operator overloading can be achieved like the below example. '+' operator behaves differently for the different input data types #Operator Overloading # '+' operator perform addition operation for numbers num1 = 10 num2 = 20 print(num1+num2) # '+' operator perform concatenation for strings word1 = \"Rathna \" word2 = \"Schools\" print(word1+word2)","title":"Operator Overloading"},{"location":"python/python_polymorphism/#method-overriding","text":"Overriding the parent method definition in their child class is called as method overriding. Below is the simple example for method overriding in python. class Shape: def draw(self): pass class Square(Shape): def draw(self): print(\"I am drawing a square\") class Circle(Shape): def draw(self): print(\"I am drawing a circle\") #Similar to class polymorphism but here child class methods override the parent method for shape in (Square(), Circle()): shape.draw() Output I am drawing a square I am drawing a circle","title":"Method Overriding"},{"location":"python/python_polymorphism/#method-overloading","text":"In other programming language, we can achieve method overloading by calling the method with different number of arguments. But, its impossible in python which always consider the last definition of the method. class Shape: def draw(self): pass class Circle(Shape): def draw(self): print(\"I am drawing a circe\") def draw(self, radius): print(\"I am drawing a circle with {}cm\".format(radius)) circle = Circle() #This method works without any issues circle.draw(10) #Raises Exception, since second(last) draw method overrides the first(previous) method circle.draw() Output I am drawing a circle with 10cm Traceback (most recent call last): File \"<string>\", line 16, in <module> TypeError: draw() missing 1 required positional argument: 'radius'","title":"Method Overloading"},{"location":"python/python_property/","text":"Property is one of the most important concepts in python. Its performs the same operation of getter and setter in other programing languages Normal function Below program is a simple one which is not validating the age of the voter and allow them to add in voter list class Voters: def __init__(self, name, age): self.name = name self.age = age def add_to_voter_list(self): print(\"Name: {} | Age: {} - Added to voters list successfully\".format(self.name, self.age)) voter = Voters(\"John\", 22) voter.add_to_voter_list() Output Name: John | Age: 22 - Added to voters list successfully Get and Set function To overcome the problem in above program, we have implemented the get and set age functions and also validating the age is greater than 18 class Voters: def __init__(self, name, age): self.name = name self.set_age(age) def add_to_voter_list(self): print(\"Name: {} | Age: {} - Added to voters list successfully\".format(self.name, self.age)) #Getting the age def get_age(self): return self.age #Setting the age def set_age(self, age): if age>18: self.age = age else: raise ValueError(\"Age should be greater than 18\") voter1 = Voters(\"John\", 28) voter1.add_to_voter_list() voter2 = Voters(\"David\", 15) voter2.add_to_voter_list() Output Name: John | Age: 28 - Added to voters list successfully Traceback (most recent call last): File \"<string>\", line 21, in <module> File \"<string>\", line 4, in __init__ File \"<string>\", line 16, in set_age ValueError: Age should be greater than 18 Issue in get and set method without property But this program also have another issue, it is not allowing voter object to access its age attribute class Voters: def __init__(self, name, age): self.name = name self.set_age(age) def add_to_voter_list(self): print(\"Name: {} | Age: {} - Added to voters list successfully\".format(self.name, self._age)) #Getting the age def get_age(self): return self._age #Setting the age def set_age(self, age): if age>18: self._age = age else: raise ValueError(\"Age should be greater than 18\") voter1 = Voters(\"John\", 28) voter1.add_to_voter_list() print(voter1.name) #It raises the error print(voter1.age) Output Name: John | Age: 28 - Added to voters list successfully John Traceback (most recent call last): File \"<string>\", line 23, in <module> AttributeError: 'Voters' object has no attribute 'age' Property class implementation With the help of property class declaration for age, we can overcome the above issue and also validate the age value in our code like the below example program class Voters: def __init__(self, name, age): self.name = name self.set_age(age) def add_to_voter_list(self): print(\"Name: {} | Age: {} - Added to voters list successfully\".format(self.name, self._age)) #Getting the age def get_age(self): return self._age #Setting the age def set_age(self, age): if age>18: self._age = age else: raise ValueError(\"Age should be greater than 18\") #property declaration resolves the issue age = property(get_age, set_age) voter1 = Voters(\"John\", 28) voter1.add_to_voter_list() print(voter1.name) print(voter1.age) Output Name: John | Age: 28 - Added to voters list successfully John 28 Property Annotation The same functionality can be achieved with the help of property annotations like the below example. Its pythonic way of implementing getter and setter functionality in our programs class Voters: def init (self, name, age): self.name = name self.age = age def add_to_voter_list(self): print(\"Name: {} | Age: {} - Added to voters list successfully\".format(self.name, self.age)) @property def age(self): return self._age @age.setter def age(self, value): if value>18: self._age = value else: raise ValueError(\"Age should be greater than 18\") voter1 = Voters(\"John\", 22) voter1.add_to_voter_list() print(voter1.name) print(voter1.age) Output Name: John | Age: 22 - Added to voters list successfully John 22","title":"Python Property"},{"location":"python/python_property/#normal-function","text":"Below program is a simple one which is not validating the age of the voter and allow them to add in voter list class Voters: def __init__(self, name, age): self.name = name self.age = age def add_to_voter_list(self): print(\"Name: {} | Age: {} - Added to voters list successfully\".format(self.name, self.age)) voter = Voters(\"John\", 22) voter.add_to_voter_list() Output Name: John | Age: 22 - Added to voters list successfully","title":"Normal function"},{"location":"python/python_property/#get-and-set-function","text":"To overcome the problem in above program, we have implemented the get and set age functions and also validating the age is greater than 18 class Voters: def __init__(self, name, age): self.name = name self.set_age(age) def add_to_voter_list(self): print(\"Name: {} | Age: {} - Added to voters list successfully\".format(self.name, self.age)) #Getting the age def get_age(self): return self.age #Setting the age def set_age(self, age): if age>18: self.age = age else: raise ValueError(\"Age should be greater than 18\") voter1 = Voters(\"John\", 28) voter1.add_to_voter_list() voter2 = Voters(\"David\", 15) voter2.add_to_voter_list() Output Name: John | Age: 28 - Added to voters list successfully Traceback (most recent call last): File \"<string>\", line 21, in <module> File \"<string>\", line 4, in __init__ File \"<string>\", line 16, in set_age ValueError: Age should be greater than 18","title":"Get and Set function"},{"location":"python/python_property/#issue-in-get-and-set-method-without-property","text":"But this program also have another issue, it is not allowing voter object to access its age attribute class Voters: def __init__(self, name, age): self.name = name self.set_age(age) def add_to_voter_list(self): print(\"Name: {} | Age: {} - Added to voters list successfully\".format(self.name, self._age)) #Getting the age def get_age(self): return self._age #Setting the age def set_age(self, age): if age>18: self._age = age else: raise ValueError(\"Age should be greater than 18\") voter1 = Voters(\"John\", 28) voter1.add_to_voter_list() print(voter1.name) #It raises the error print(voter1.age) Output Name: John | Age: 28 - Added to voters list successfully John Traceback (most recent call last): File \"<string>\", line 23, in <module> AttributeError: 'Voters' object has no attribute 'age'","title":"Issue in get and set method without property"},{"location":"python/python_property/#property-class-implementation","text":"With the help of property class declaration for age, we can overcome the above issue and also validate the age value in our code like the below example program class Voters: def __init__(self, name, age): self.name = name self.set_age(age) def add_to_voter_list(self): print(\"Name: {} | Age: {} - Added to voters list successfully\".format(self.name, self._age)) #Getting the age def get_age(self): return self._age #Setting the age def set_age(self, age): if age>18: self._age = age else: raise ValueError(\"Age should be greater than 18\") #property declaration resolves the issue age = property(get_age, set_age) voter1 = Voters(\"John\", 28) voter1.add_to_voter_list() print(voter1.name) print(voter1.age) Output Name: John | Age: 28 - Added to voters list successfully John 28","title":"Property class implementation"},{"location":"python/python_property/#property-annotation","text":"The same functionality can be achieved with the help of property annotations like the below example. Its pythonic way of implementing getter and setter functionality in our programs class Voters: def init (self, name, age): self.name = name self.age = age def add_to_voter_list(self): print(\"Name: {} | Age: {} - Added to voters list successfully\".format(self.name, self.age)) @property def age(self): return self._age @age.setter def age(self, value): if value>18: self._age = value else: raise ValueError(\"Age should be greater than 18\") voter1 = Voters(\"John\", 22) voter1.add_to_voter_list() print(voter1.name) print(voter1.age) Output Name: John | Age: 22 - Added to voters list successfully John 22","title":"Property Annotation"},{"location":"python/python_regex/","text":"Reg ular Ex pression is shortly called as RegEx which helps to search a string which contain the specified search pattern. re module helps to perform regex operations in python Metacharacters Metacharacters are used to specify the regular expressions. The list of metacharacters are []{}()\\|.?$^*+ . Each character's usage explained in the below sections Note : https://pythex.org/ is a best website to test the regular expressions Square Brackets [ ] With the help of square bracket, we can specify a set of characters to match with the given string Expression String Number of Matches a 1 Match au 2 Matches [aeiou] rathna schools 4 Matches myth No Match ieauo 5 Matches We can specify the range of characters using - such as [a-e] is consider as [abcde] similarly [0-5] is consider as [012345] Complement operators inverse the character list such as [^a] is consider as any characters except a similarly [^0-9] is consider as any non digit characters Period . 1 period matches 1 characters incase 2 period means, it wil match 2 characters and so on. But, it won't consider the newline \\n Expression String Number of Matches . a 1 Match .. au 2 Matches . rathnaschools 13 Matches .. rathnaschools 6 Matches ... ieauo 1 match Caret ^ Caret symbol is used to check the prefix of the given string and returns whether it match or not Expression String Number of Matches ^a rathnaschools No match ^r au Match ^R rathnaschools No match ^rs rathnaschools No match ^ra rathnaschools match Dollar $ Dollar symbol is used to check the suffix of the given string and returns whether it match or not Expression String Number of Matches a$ rathnaschools No match s$ au Match S$ rathnaschools No match rs$ rathnaschools No match ls$ rathnaschools match Star * Star symbol used to match the zero or multiple occurrences of the pattern left to the given string Expression String Number of Matches pytho*n pythn Match pytho*n python Match pytho*n pythoooon Match pytho*n pythoan No match pytho*n learnpython match Plus + Plus symbol used to match the zero or multiple occurrences of the pattern right to the given string Expression String Number of Matches pytho+n pythn No match pytho+n python Match pytho+n pythoooon Match pytho+n pythoan No match pytho+n pythonlearn match Question Mark ? Question Mark symbol used to match the zero or multiple occurrences of the pattern left to the given string Expression String Number of Matches pytho?n pythn Match pytho?n python Match pytho?n pythoooon No Match (more than one 'o') pytho?n pythoan No match pytho?n learnpython match Braces { } Braces are used to find the repetitive pattern in the given string with {at least, at most} specifications. example if it {2, 3} means minimum two time character should repeat and at most three time in the given string Expression String Number of Matches o{2,3} verbose No Match o{2,3} verboose Match o{2,3} verboose schools 2 Match o{2,3} verbooose schools 2 Match o{2,3} verbooooose schools 3 Match Vertical Bar | Vertical bar | performs the same operation of OR operators in programming language Expression String Number of Matches p|o python 2 match p|o learn No Match p|o python python 4 Match Parentheses ( ) Parentheses are used to match the sub-patterns in the given input string Expression String Number of Matches (a|h|n)on python 1 match (a|e|n)on python No Match (a|h|r)on learon python 2 Match Backslash Backslash is act as an escape characters including all metacharacters. If we want to search $50 in the given string means, we need to skip the $ symbol like below Expression String Number of Matches $50 The balance is $50. No match \\$50 The balance is $50. 1 Match Special Sequence The regularly using patterns can be easily written with special sequence. The list of special sequences are Expression Description String Number of Matches \\Alearn Check the start of the string learn python 1 Match python\\Z Check the end of the string learn python 1 Match \\blearn Check the start of the string learn python 1 Match python\\b Check the end of the string learn python 1 Match \\Blearn Check the not start of the string learn python No Match python\\B Check the not end of the string learn python No Match \\d returns the integers in the string learn python 123 123 \\D returns the non integers in the string learn python 123 learn python \\s returns the white space in the string learn python 2 white spaces \\S returns the non white space in the string learn python learnpython123 \\w returns the alpha numeric in the string learn python 123 learnpython123 \\W returns the non alpha numeric in the string learn python 123 2 white spaces re findall method Findall method in re module helps to return the matching pattern in the given string import re input_data = \"Learn 123 python 456\" pattern = \"\\d+\" result = re.findall(pattern, input_data) print(result) Output ['123', '456'] re split method Split method in re module helps to split the string based on the matching pattern in the given string import re input_data = \"Learn 123 python 456\" pattern = \"\\d+\" result = re.split(pattern, input_data) print(result) Output ['Learn ', ' python ', ''] re sub method Sub method in re module helps to replace the string based on the matching pattern in the given string import re input_data = \"Learn 123 python 456\" pattern = \"\\d+\" replace = \"***\" result = re.sub(pattern, replace, input_data) print(result) Output Learn *** python *** re subn method Subn method in re module helps to replace the string based on the matching pattern and also returns the count of number of occurrence in the given string import re input_data = \"Learn 123 python 456\" pattern = \"\\d+\" replace = \"***\" result = re.subn(pattern, replace, input_data) print(result) Output ('Learn *** python ***', 2) re search method Search method in re module helps to search the string based on the matching pattern and returns none if the pattern is not available in the given string import re input_data = \"Learn 123 python 456\" pattern = \"\\d+\" result = re.search(pattern, input_data) if result: print(\"Integer available in the given string\") else: print(\"No integer in the given string\") Output Integer available in the given string","title":"Python Regex"},{"location":"python/python_regex/#metacharacters","text":"Metacharacters are used to specify the regular expressions. The list of metacharacters are []{}()\\|.?$^*+ . Each character's usage explained in the below sections Note : https://pythex.org/ is a best website to test the regular expressions","title":"Metacharacters"},{"location":"python/python_regex/#square-brackets","text":"With the help of square bracket, we can specify a set of characters to match with the given string Expression String Number of Matches a 1 Match au 2 Matches [aeiou] rathna schools 4 Matches myth No Match ieauo 5 Matches We can specify the range of characters using - such as [a-e] is consider as [abcde] similarly [0-5] is consider as [012345] Complement operators inverse the character list such as [^a] is consider as any characters except a similarly [^0-9] is consider as any non digit characters","title":"Square Brackets [ ]"},{"location":"python/python_regex/#period","text":"1 period matches 1 characters incase 2 period means, it wil match 2 characters and so on. But, it won't consider the newline \\n Expression String Number of Matches . a 1 Match .. au 2 Matches . rathnaschools 13 Matches .. rathnaschools 6 Matches ... ieauo 1 match","title":"Period ."},{"location":"python/python_regex/#caret","text":"Caret symbol is used to check the prefix of the given string and returns whether it match or not Expression String Number of Matches ^a rathnaschools No match ^r au Match ^R rathnaschools No match ^rs rathnaschools No match ^ra rathnaschools match","title":"Caret ^"},{"location":"python/python_regex/#dollar","text":"Dollar symbol is used to check the suffix of the given string and returns whether it match or not Expression String Number of Matches a$ rathnaschools No match s$ au Match S$ rathnaschools No match rs$ rathnaschools No match ls$ rathnaschools match","title":"Dollar $"},{"location":"python/python_regex/#star","text":"Star symbol used to match the zero or multiple occurrences of the pattern left to the given string Expression String Number of Matches pytho*n pythn Match pytho*n python Match pytho*n pythoooon Match pytho*n pythoan No match pytho*n learnpython match","title":"Star *"},{"location":"python/python_regex/#plus","text":"Plus symbol used to match the zero or multiple occurrences of the pattern right to the given string Expression String Number of Matches pytho+n pythn No match pytho+n python Match pytho+n pythoooon Match pytho+n pythoan No match pytho+n pythonlearn match","title":"Plus +"},{"location":"python/python_regex/#question-mark","text":"Question Mark symbol used to match the zero or multiple occurrences of the pattern left to the given string Expression String Number of Matches pytho?n pythn Match pytho?n python Match pytho?n pythoooon No Match (more than one 'o') pytho?n pythoan No match pytho?n learnpython match","title":"Question Mark ?"},{"location":"python/python_regex/#braces","text":"Braces are used to find the repetitive pattern in the given string with {at least, at most} specifications. example if it {2, 3} means minimum two time character should repeat and at most three time in the given string Expression String Number of Matches o{2,3} verbose No Match o{2,3} verboose Match o{2,3} verboose schools 2 Match o{2,3} verbooose schools 2 Match o{2,3} verbooooose schools 3 Match","title":"Braces { }"},{"location":"python/python_regex/#vertical-bar","text":"Vertical bar | performs the same operation of OR operators in programming language Expression String Number of Matches p|o python 2 match p|o learn No Match p|o python python 4 Match","title":"Vertical Bar |"},{"location":"python/python_regex/#parentheses","text":"Parentheses are used to match the sub-patterns in the given input string Expression String Number of Matches (a|h|n)on python 1 match (a|e|n)on python No Match (a|h|r)on learon python 2 Match","title":"Parentheses ( )"},{"location":"python/python_regex/#backslash","text":"Backslash is act as an escape characters including all metacharacters. If we want to search $50 in the given string means, we need to skip the $ symbol like below Expression String Number of Matches $50 The balance is $50. No match \\$50 The balance is $50. 1 Match","title":"Backslash"},{"location":"python/python_regex/#special-sequence","text":"The regularly using patterns can be easily written with special sequence. The list of special sequences are Expression Description String Number of Matches \\Alearn Check the start of the string learn python 1 Match python\\Z Check the end of the string learn python 1 Match \\blearn Check the start of the string learn python 1 Match python\\b Check the end of the string learn python 1 Match \\Blearn Check the not start of the string learn python No Match python\\B Check the not end of the string learn python No Match \\d returns the integers in the string learn python 123 123 \\D returns the non integers in the string learn python 123 learn python \\s returns the white space in the string learn python 2 white spaces \\S returns the non white space in the string learn python learnpython123 \\w returns the alpha numeric in the string learn python 123 learnpython123 \\W returns the non alpha numeric in the string learn python 123 2 white spaces","title":"Special Sequence"},{"location":"python/python_regex/#re-findall-method","text":"Findall method in re module helps to return the matching pattern in the given string import re input_data = \"Learn 123 python 456\" pattern = \"\\d+\" result = re.findall(pattern, input_data) print(result) Output ['123', '456']","title":"re findall method"},{"location":"python/python_regex/#re-split-method","text":"Split method in re module helps to split the string based on the matching pattern in the given string import re input_data = \"Learn 123 python 456\" pattern = \"\\d+\" result = re.split(pattern, input_data) print(result) Output ['Learn ', ' python ', '']","title":"re split method"},{"location":"python/python_regex/#re-sub-method","text":"Sub method in re module helps to replace the string based on the matching pattern in the given string import re input_data = \"Learn 123 python 456\" pattern = \"\\d+\" replace = \"***\" result = re.sub(pattern, replace, input_data) print(result) Output Learn *** python ***","title":"re sub method"},{"location":"python/python_regex/#re-subn-method","text":"Subn method in re module helps to replace the string based on the matching pattern and also returns the count of number of occurrence in the given string import re input_data = \"Learn 123 python 456\" pattern = \"\\d+\" replace = \"***\" result = re.subn(pattern, replace, input_data) print(result) Output ('Learn *** python ***', 2)","title":"re subn method"},{"location":"python/python_regex/#re-search-method","text":"Search method in re module helps to search the string based on the matching pattern and returns none if the pattern is not available in the given string import re input_data = \"Learn 123 python 456\" pattern = \"\\d+\" result = re.search(pattern, input_data) if result: print(\"Integer available in the given string\") else: print(\"No integer in the given string\") Output Integer available in the given string","title":"re search method"},{"location":"python/python_sets/","text":"Sets are used to store multiple items in single variable as similar to list. But, Sets are unordered and not indexed and also has no duplicate elements. Set Creation Set created by declare all the items inside the curly brackets {} #Set Creation languages = {\"Python\", \"Java\", \"Javascript\"} print(type(languages)) #Unordered and Non duplicated languages = {\"Python\", \"Java\", \"Javascript\", \"Java\"} print(languages) Output <class 'set'> {'Javascript', 'Python', 'Java'} It can store any immutable (int, float, string etc..) data. It cannot store any mutable (like list) data which raises exception #Set Creation #Mutable data type(like list) addition raises exception user_details = {1, \"PYTHON\", \"99.0\", [\"Jan\", \"Feb\"]} print(user_details) Output Traceback (most recent call last): File \"<string>\", line 4, in <module> TypeError: unhashable type: 'list' Set Reading Since sets are unordered and unindexed, we cannot read the element using index which raises exception #Set Reading languages = {\"Python\", \"Java\", \"Javascript\"} print(languages[0]) Output Traceback (most recent call last): File \"<string>\", line 3, in <module> TypeError: 'set' object is not subscriptable We need to loop each and every element and access the set objects #Set Reading languages = {\"Python\", \"Java\", \"Javascript\"} #Looping each element and print the same for each in languages: print(each) Output Python Javascript Java Set Update In sets, we cannot update the specific element, but we can append items from another set since they are mutable in nature #Set Update languages = {\"Python\", \"Java\", \"Javascript\"} languages[4] = \"C++\" Output Traceback (most recent call last): File \"<string>\", line 3, in <module> TypeError: 'set' object does not support item assignment But, We can add the new set to the existing set since they are mutable in nature #Set Update languages = {\"Python\", \"Java\", \"Javascript\"} #Adding new set to existing set languages_new = {\"C++\", \"R\"} languages.update(languages_new) print(languages) Output {'C++', 'Java', 'Python', 'Javascript', 'R'} Set Deletion In sets, we can perform the specific deletion as like in list using either remove or discard function #Set Deletion languages = {\"Python\", \"Java\", \"Javascript\"} #Remove Function languages.remove(\"Java\") print(languages) Output {'Python', 'Javascript'} Remove function - throws error if the element not available in the given set #Set Deletion languages = {\"Python\", \"Java\", \"Javascript\"} #Remove method raises exception for missing key languages.remove(\"C++\") Output Traceback (most recent call last): File \"<string>\", line 5, in <module> KeyError: 'C++' Discard function - won't throws the error if the set is not available in given set #Set Deletion languages = {\"Python\", \"Java\", \"Javascript\"} #Discard method won't raises exception for missing key languages.discard(\"C++\") print(languages) Output {'Java', 'Javascript', 'Python'} Set Slicing Since sets are unordered and unindexed, we cannot slice the set element using index #Set slicing languages = {\"Python\", \"Java\", \"Javascript\"} print(languages[:2]) Output Traceback (most recent call last): File \"<string>\", line 3, in <module> TypeError: 'set' object is not subscriptable We need to loop each and every element and access the set objects #Set slicing languages = {\"Python\", \"Java\", \"Javascript\"} #Looping each and print the element for each in languages: print(each) Output Java Python Javascript","title":"Python Sets"},{"location":"python/python_sets/#set-creation","text":"Set created by declare all the items inside the curly brackets {} #Set Creation languages = {\"Python\", \"Java\", \"Javascript\"} print(type(languages)) #Unordered and Non duplicated languages = {\"Python\", \"Java\", \"Javascript\", \"Java\"} print(languages) Output <class 'set'> {'Javascript', 'Python', 'Java'} It can store any immutable (int, float, string etc..) data. It cannot store any mutable (like list) data which raises exception #Set Creation #Mutable data type(like list) addition raises exception user_details = {1, \"PYTHON\", \"99.0\", [\"Jan\", \"Feb\"]} print(user_details) Output Traceback (most recent call last): File \"<string>\", line 4, in <module> TypeError: unhashable type: 'list'","title":"Set Creation"},{"location":"python/python_sets/#set-reading","text":"Since sets are unordered and unindexed, we cannot read the element using index which raises exception #Set Reading languages = {\"Python\", \"Java\", \"Javascript\"} print(languages[0]) Output Traceback (most recent call last): File \"<string>\", line 3, in <module> TypeError: 'set' object is not subscriptable We need to loop each and every element and access the set objects #Set Reading languages = {\"Python\", \"Java\", \"Javascript\"} #Looping each element and print the same for each in languages: print(each) Output Python Javascript Java","title":"Set Reading"},{"location":"python/python_sets/#set-update","text":"In sets, we cannot update the specific element, but we can append items from another set since they are mutable in nature #Set Update languages = {\"Python\", \"Java\", \"Javascript\"} languages[4] = \"C++\" Output Traceback (most recent call last): File \"<string>\", line 3, in <module> TypeError: 'set' object does not support item assignment But, We can add the new set to the existing set since they are mutable in nature #Set Update languages = {\"Python\", \"Java\", \"Javascript\"} #Adding new set to existing set languages_new = {\"C++\", \"R\"} languages.update(languages_new) print(languages) Output {'C++', 'Java', 'Python', 'Javascript', 'R'}","title":"Set Update"},{"location":"python/python_sets/#set-deletion","text":"In sets, we can perform the specific deletion as like in list using either remove or discard function #Set Deletion languages = {\"Python\", \"Java\", \"Javascript\"} #Remove Function languages.remove(\"Java\") print(languages) Output {'Python', 'Javascript'} Remove function - throws error if the element not available in the given set #Set Deletion languages = {\"Python\", \"Java\", \"Javascript\"} #Remove method raises exception for missing key languages.remove(\"C++\") Output Traceback (most recent call last): File \"<string>\", line 5, in <module> KeyError: 'C++' Discard function - won't throws the error if the set is not available in given set #Set Deletion languages = {\"Python\", \"Java\", \"Javascript\"} #Discard method won't raises exception for missing key languages.discard(\"C++\") print(languages) Output {'Java', 'Javascript', 'Python'}","title":"Set Deletion"},{"location":"python/python_sets/#set-slicing","text":"Since sets are unordered and unindexed, we cannot slice the set element using index #Set slicing languages = {\"Python\", \"Java\", \"Javascript\"} print(languages[:2]) Output Traceback (most recent call last): File \"<string>\", line 3, in <module> TypeError: 'set' object is not subscriptable We need to loop each and every element and access the set objects #Set slicing languages = {\"Python\", \"Java\", \"Javascript\"} #Looping each and print the element for each in languages: print(each) Output Java Python Javascript","title":"Set Slicing"},{"location":"python/python_strings/","text":"In Python, a string is a sequence of Unicode characters. Unicode was introduced to include every character in all languages and bring uniformity in encoding. String Creation Python provides multiple number of ways to create a string literal #String Creation #Enclosed with single quotes single_quoted_data = 'I am created with single quote' print(single_quoted_data) #Enclosed with double quotes double_quoted_data = \"I am created with double quotes\" print(double_quoted_data) #Enclosed with triple single quotes triple_single_quoted_data = '''I am created with triple single quotes''' print(triple_single_quoted_data) #Enclosed with triple double quotes triple_double_quoted_data = \"\"\"I am created with triple double quotes\"\"\" print(triple_double_quoted_data) Output I am created with single quote I am created with double quotes I am created with triple single quotes I am created with triple double quotes String Reading Read a character with the help of positive and negative index value P Y T H O N 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1 Every character have one positive and negative index in the string like the above example #String Reading school_name = \"RATHNASCHOOLS\" #Reading the first character of the string print(school_name[0]) print(school_name[-13]) #Reading the second character of the string print(school_name[1]) print(school_name[-12]) #Reading the last character of the string print(school_name[12]) print(school_name[-1]) Output R R A A S S String Update Strings are immutable, which means that cannot update once created #String Update school_name = \"RATHNASCHOOLS\" #Item assignment impossible for immutable objects school_name[1] = \"E\" Output Traceback (most recent call last): File \"<string>\", line 5, in <module> TypeError: 'str' object does not support item assignment Recreation of entire object is the only way for update the immutable objects in python #String Update school_name = \"RATHNASCHOOLS\" #Object Recreation school_name = \"RETHNASCHOOLS\" print(school_name) Output RETHNASCHOOLS String Deletion Strings are immutable, which means that cannot delete once created #String Deletion school_name = \"RATHNASCHOOLS\" #Item deletion impossible for immutable objects del school_name[0] Output Traceback (most recent call last): File \"<string>\", line 5, in <module> TypeError: 'str' object doesn't support item deletion Entire object can delete but not a substring in python #String Deletion school_name = \"RATHNASCHOOLS\" #Entire object deletion is possible del school_name print(school_name) String Slicing String slice helps to return the required substring for the given string string_name(start Index: stop Index: step Value(optional)] start Index Not declare means, first value index consider by python stop Index Not declare means, last value index consider by python P Y T H O N 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1 #String Slicing school_name = \"RATHNASCHOOLS\" #Print the first three characters print(school_name[0:3]) print(school_name[-13:3]) print(school_name[:3]) #Print the middle three characters print(school_name[6:9]) print(school_name[-7:9]) #Print the last two characters print(school_name[11:13]) print(school_name[-2:13]) print(school_name[11:]) Output RAT RAT RAT SCH SCH LS LS LS","title":"Python Strings"},{"location":"python/python_strings/#string-creation","text":"Python provides multiple number of ways to create a string literal #String Creation #Enclosed with single quotes single_quoted_data = 'I am created with single quote' print(single_quoted_data) #Enclosed with double quotes double_quoted_data = \"I am created with double quotes\" print(double_quoted_data) #Enclosed with triple single quotes triple_single_quoted_data = '''I am created with triple single quotes''' print(triple_single_quoted_data) #Enclosed with triple double quotes triple_double_quoted_data = \"\"\"I am created with triple double quotes\"\"\" print(triple_double_quoted_data) Output I am created with single quote I am created with double quotes I am created with triple single quotes I am created with triple double quotes","title":"String Creation"},{"location":"python/python_strings/#string-reading","text":"Read a character with the help of positive and negative index value P Y T H O N 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1 Every character have one positive and negative index in the string like the above example #String Reading school_name = \"RATHNASCHOOLS\" #Reading the first character of the string print(school_name[0]) print(school_name[-13]) #Reading the second character of the string print(school_name[1]) print(school_name[-12]) #Reading the last character of the string print(school_name[12]) print(school_name[-1]) Output R R A A S S","title":"String Reading"},{"location":"python/python_strings/#string-update","text":"Strings are immutable, which means that cannot update once created #String Update school_name = \"RATHNASCHOOLS\" #Item assignment impossible for immutable objects school_name[1] = \"E\" Output Traceback (most recent call last): File \"<string>\", line 5, in <module> TypeError: 'str' object does not support item assignment Recreation of entire object is the only way for update the immutable objects in python #String Update school_name = \"RATHNASCHOOLS\" #Object Recreation school_name = \"RETHNASCHOOLS\" print(school_name) Output RETHNASCHOOLS","title":"String Update"},{"location":"python/python_strings/#string-deletion","text":"Strings are immutable, which means that cannot delete once created #String Deletion school_name = \"RATHNASCHOOLS\" #Item deletion impossible for immutable objects del school_name[0] Output Traceback (most recent call last): File \"<string>\", line 5, in <module> TypeError: 'str' object doesn't support item deletion Entire object can delete but not a substring in python #String Deletion school_name = \"RATHNASCHOOLS\" #Entire object deletion is possible del school_name print(school_name)","title":"String Deletion"},{"location":"python/python_strings/#string-slicing","text":"String slice helps to return the required substring for the given string string_name(start Index: stop Index: step Value(optional)] start Index Not declare means, first value index consider by python stop Index Not declare means, last value index consider by python P Y T H O N 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1 #String Slicing school_name = \"RATHNASCHOOLS\" #Print the first three characters print(school_name[0:3]) print(school_name[-13:3]) print(school_name[:3]) #Print the middle three characters print(school_name[6:9]) print(school_name[-7:9]) #Print the last two characters print(school_name[11:13]) print(school_name[-2:13]) print(school_name[11:]) Output RAT RAT RAT SCH SCH LS LS LS","title":"String Slicing"},{"location":"python/python_tuples/","text":"Similar to lists, tuples are also used to store multiple object in a variable. But the tuples are fixed which cannot change once its created - IMMUTABLE data type. It can store any type (int, float, string etc..) of data and they can be accessed using both positive and negative indexes as similar to list data Tuple Creation Tuple created by declare all the items inside the round brackets () #Tuple Creation languages = (\"Python\", \"Java\", \"Javascript\") print(type(languages)) #Multiple data types can store in list user_details = (1, \"PYTHON\", \"99.0\", [\"Jan\", \"Feb\"]) print(user_details) #In case of single item, comma is mandatory without_comma_item = (\"Jan\") with_comma_item = (\"Jan\",) print(type(without_comma_item), type(with_comma_item)) Output <class 'tuple'> (1, 'PYTHON', '99.0', ['Jan', 'Feb']) <class 'str'> <class 'tuple'> Tuple Reading As similar to list, tuple data items can be read with both positive ann negative index \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1 Every item in the list have both positive and negative index like the above table #Tuple Reading month_list = (\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\") #Reading the first item of the tuple print(month_list[0]) print(month_list[-6]) #Reading the second item of the tuple print(month_list[1]) print(month_list[-5]) #Reading the last item of the tuple print(month_list[5]) print(month_list[-1]) Output Jan Jan Feb Feb Jun Jun Tuple Update Tuple are immutable data types in python, so we cannot perform the update operation #Tuple Update month_list = (\"Jan\", \"Dec\", \"Mar\", \"Apr\", \"May\", \"Jun\") #Update using index of the item raise exception month_list[1] = \"Feb\" Output Traceback (most recent call last): File \"<string>\", line 5, in <module> TypeError: 'tuple' object does not support item assignment Needs to recreate the entire object due to its immutability #Tuple Update month_list = (\"Jan\", \"Dec\", \"Mar\", \"Apr\", \"May\", \"Jun\") print(id(month_list)) #Recreating the entire object month_list = (\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\") print(id(month_list)) print(month_list) Output 140186154916736 140186155260128 ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun') Tuple Deletion Tuple are immutable data types in python, so we cannot perform the specific deletion which we can do in a list #Tuple Deletion month_list = (\"Jan\", \"Dec\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\") #Specific element deletion raises exception month_list.remove(\"Dec\") Output Traceback (most recent call last): File \"<string>\", line 5, in <module> AttributeError: 'tuple' object has no attribute 'remove' Entire object requires to delete in Tuple in case of new modification #Tuple Deletion month_list = (\"Jan\", \"Dec\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\") #Deletion the entire item del month_list print(month_list) Output Traceback (most recent call last): File \"<string>\", line 6, in <module> NameError: name 'month_list' is not defined Tuple Slicing Tuple slicing helps to return the required objects from the given tuple TupleName(start Index: stop Index: step Value (optional)] start Index Not declare means, first value index consider by python stop Index Not declare means, last value index consider by python Read a object with the help of positive and negative index value \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1 #Tuple Slicing month_list = (\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\") #Print the first two items print(month_list[0:2]) print(month_list[-6:2]) print(month_list[:2]) #Print the middle two items print(month_list[2:4]) print(month_list[-4:4]) #Print the last two items print(month_list[4:6]) print(month_list[-2:6]) print(month_list[4:]) Output ('Jan', 'Feb') ('Jan', 'Feb') ('Jan', 'Feb') ('Mar', 'Apr') ('Mar', 'Apr') ('May', 'Jun') ('May', 'Jun') ('May', 'Jun')","title":"Python Tuples"},{"location":"python/python_tuples/#tuple-creation","text":"Tuple created by declare all the items inside the round brackets () #Tuple Creation languages = (\"Python\", \"Java\", \"Javascript\") print(type(languages)) #Multiple data types can store in list user_details = (1, \"PYTHON\", \"99.0\", [\"Jan\", \"Feb\"]) print(user_details) #In case of single item, comma is mandatory without_comma_item = (\"Jan\") with_comma_item = (\"Jan\",) print(type(without_comma_item), type(with_comma_item)) Output <class 'tuple'> (1, 'PYTHON', '99.0', ['Jan', 'Feb']) <class 'str'> <class 'tuple'>","title":"Tuple Creation"},{"location":"python/python_tuples/#tuple-reading","text":"As similar to list, tuple data items can be read with both positive ann negative index \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1 Every item in the list have both positive and negative index like the above table #Tuple Reading month_list = (\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\") #Reading the first item of the tuple print(month_list[0]) print(month_list[-6]) #Reading the second item of the tuple print(month_list[1]) print(month_list[-5]) #Reading the last item of the tuple print(month_list[5]) print(month_list[-1]) Output Jan Jan Feb Feb Jun Jun","title":"Tuple Reading"},{"location":"python/python_tuples/#tuple-update","text":"Tuple are immutable data types in python, so we cannot perform the update operation #Tuple Update month_list = (\"Jan\", \"Dec\", \"Mar\", \"Apr\", \"May\", \"Jun\") #Update using index of the item raise exception month_list[1] = \"Feb\" Output Traceback (most recent call last): File \"<string>\", line 5, in <module> TypeError: 'tuple' object does not support item assignment Needs to recreate the entire object due to its immutability #Tuple Update month_list = (\"Jan\", \"Dec\", \"Mar\", \"Apr\", \"May\", \"Jun\") print(id(month_list)) #Recreating the entire object month_list = (\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\") print(id(month_list)) print(month_list) Output 140186154916736 140186155260128 ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun')","title":"Tuple Update"},{"location":"python/python_tuples/#tuple-deletion","text":"Tuple are immutable data types in python, so we cannot perform the specific deletion which we can do in a list #Tuple Deletion month_list = (\"Jan\", \"Dec\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\") #Specific element deletion raises exception month_list.remove(\"Dec\") Output Traceback (most recent call last): File \"<string>\", line 5, in <module> AttributeError: 'tuple' object has no attribute 'remove' Entire object requires to delete in Tuple in case of new modification #Tuple Deletion month_list = (\"Jan\", \"Dec\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\") #Deletion the entire item del month_list print(month_list) Output Traceback (most recent call last): File \"<string>\", line 6, in <module> NameError: name 'month_list' is not defined","title":"Tuple Deletion"},{"location":"python/python_tuples/#tuple-slicing","text":"Tuple slicing helps to return the required objects from the given tuple TupleName(start Index: stop Index: step Value (optional)] start Index Not declare means, first value index consider by python stop Index Not declare means, last value index consider by python Read a object with the help of positive and negative index value \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1 #Tuple Slicing month_list = (\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\") #Print the first two items print(month_list[0:2]) print(month_list[-6:2]) print(month_list[:2]) #Print the middle two items print(month_list[2:4]) print(month_list[-4:4]) #Print the last two items print(month_list[4:6]) print(month_list[-2:6]) print(month_list[4:]) Output ('Jan', 'Feb') ('Jan', 'Feb') ('Jan', 'Feb') ('Mar', 'Apr') ('Mar', 'Apr') ('May', 'Jun') ('May', 'Jun') ('May', 'Jun')","title":"Tuple Slicing"},{"location":"python/python_variables/","text":"Variable is a label which helps to store data. To create a variable, we can assign it a value with the help of assignment operator. Based on the type of value assigning, the memory will dynamically allocate for the variable Example: roll_number = 12345 # roll_number is a variable # = is an assignment operator # 12345 is the value stored in roll_number variable Rules for Variable Creation Lowercase or uppercase or digits or underscore A Variable name can only contain lowercase (a to z) or uppercase (A to Z) or digits (0 to 9) or an underscore (_) No digit start A variable name cannot start with a digit (0 to 9) Lowercase and uppercase or underscore start 3. A variable name can start with a lowercase (a to z) or uppercase (A to Z) or an underscore (_) Case-Sensitive Variable name is case-sensitive (a = 5, A=6 -> a and A are two different variables in python) No Special Characters The variable name cannot have special characters such as !, @, #, $, % etc.. Multiple Assignment We can assign values to multiple variables in a single line like this a = b = c = 100 #Multiple Assignment with single value a=b=c=100 print(a, b, c) #Multiple Assignment with multiple value a, b, c = 10, 20, 30 print(a, b, c) Output 100 100 100 10 20 30 Constants in Python Constant is a value that remains the same which cannot change or modify once it get declared. Python don't have constant declaration as like in Java. We can declare a variable or value as constant in Python and make sure which don't get the modification. Rules - Constant variables should have only capital letters and underscores (for word separation) #Constant Example PI = 3.14 print(PI) Output 3.14","title":"Python Variables"},{"location":"python/python_variables/#rules-for-variable-creation","text":"Lowercase or uppercase or digits or underscore A Variable name can only contain lowercase (a to z) or uppercase (A to Z) or digits (0 to 9) or an underscore (_) No digit start A variable name cannot start with a digit (0 to 9) Lowercase and uppercase or underscore start 3. A variable name can start with a lowercase (a to z) or uppercase (A to Z) or an underscore (_) Case-Sensitive Variable name is case-sensitive (a = 5, A=6 -> a and A are two different variables in python) No Special Characters The variable name cannot have special characters such as !, @, #, $, % etc..","title":"Rules for Variable Creation"},{"location":"python/python_variables/#multiple-assignment","text":"We can assign values to multiple variables in a single line like this a = b = c = 100 #Multiple Assignment with single value a=b=c=100 print(a, b, c) #Multiple Assignment with multiple value a, b, c = 10, 20, 30 print(a, b, c) Output 100 100 100 10 20 30","title":"Multiple Assignment"},{"location":"python/python_variables/#constants-in-python","text":"Constant is a value that remains the same which cannot change or modify once it get declared. Python don't have constant declaration as like in Java. We can declare a variable or value as constant in Python and make sure which don't get the modification. Rules - Constant variables should have only capital letters and underscores (for word separation) #Constant Example PI = 3.14 print(PI) Output 3.14","title":"Constants in Python"},{"location":"python/set_functions/","text":"Various built-in functions are available in Python which helps to perform multiple operations on sets. Below are the top must know set methods in python Length Function This function helps to return the length of the given set #Length Method month_list = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"} print(\"Length of given set is: {}\".format(len(month_list))) Output Length of given set is: 5 Set Union This helps to returns the union results of two sets #Set Union month_list_old = {\"Jan\", \"Feb\", \"Mar\"} month_list_new = {\"Jan\", \"Feb\", \"Apr\"} print(\"The union result of given two sets are\") print(month_list_old | month_list_new) Output The union result of given two sets are {'Apr', 'Feb', 'Mar', 'Jan'} Set Intersection This helps to return the intersection results of given sets #Set Intersection month_list_old = {\"Jan\", \"Feb\", \"Mar\"} month_list_new = {\"Jan\", \"Feb\", \"Apr\"} print(\"The intersection result of given two sets are\") print(month_list_old & month_list_new) Output The intersection result of given two sets are {'Jan', 'Feb'} Set Difference This helps to return the set difference of one set from another set #Set Difference month_list_old = {\"Jan\", \"Feb\", \"Mar\"} month_list_new = {\"Jan\", \"Feb\", \"Apr\"} print(\"The set difference of one set from another set is\") print(month_list_old - month_list_new) Output The set difference of one set from another set is {'Mar'} Set symmetric Difference This return the element which is available in any one of the given set. If it is available in both set, it won't return as result #Set Symmetric Difference month_list_old = {\"Jan\", \"Feb\", \"Mar\"} month_list_new = {\"Jan\", \"Feb\", \"Apr\"} print(\"The set symmetric difference is :\") print(month_list_old ^ month_list_new) Output The set symmetric difference is : {'Mar', 'Apr'} Clear Method This method removes all the element in given set and make it as empty set #Clear Set Method month_list = {\"Jan\", \"Feb\", \"Mar\"} month_list.clear() print(\"The clear set result is :\") print(month_list) Output The clear set result is : set() Pop Method This method helps the remove the random value from the given set #POP Method month_list = {\"Jan\", \"Feb\", \"Mar\"} month_list.pop() print(\"The POP method removes random value :\") print(month_list) Output The POP method removes random value : {'Jan', 'Feb'} Note: Since POP method removes value randomly from given set, you may end up in different output Isdisjoint Method This method returns true if both sets not have any common element #Isdisjoint Method month_list_old = {\"Jan\", \"Feb\", \"Mar\"} month_list_new = {\"Apr\", \"May\", \"Jun\"} print(\"Isdisjoint method result is :\") print(month_list_old.isdisjoint(month_list_new)) Output Isdisjoint method result is : True Issubset Method This method returns true if all element of given set is present in the another set #Issubset Method month_list_old = {\"Jan\", \"Feb\", \"Mar\"} month_list_new = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"} print(\"Issubset method result is :\") print(month_list_old.issubset(month_list_new)) Output Issubset method result is : True Issuperset Method This method returns true if the given set have all the element of another set #Issuperset Method month_list_old = {\"Jan\", \"Feb\", \"Mar\"} month_list_new = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"} #Return False - only 3 elements are present, remaining items missed print(month_list_old.issuperset(month_list_new)) #Return True - all items are present in month_list_new print(month_list_new.issuperset(month_list_old)) Output False True","title":"Set Functions"},{"location":"python/set_functions/#length-function","text":"This function helps to return the length of the given set #Length Method month_list = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"} print(\"Length of given set is: {}\".format(len(month_list))) Output Length of given set is: 5","title":"Length Function"},{"location":"python/set_functions/#set-union","text":"This helps to returns the union results of two sets #Set Union month_list_old = {\"Jan\", \"Feb\", \"Mar\"} month_list_new = {\"Jan\", \"Feb\", \"Apr\"} print(\"The union result of given two sets are\") print(month_list_old | month_list_new) Output The union result of given two sets are {'Apr', 'Feb', 'Mar', 'Jan'}","title":"Set Union"},{"location":"python/set_functions/#set-intersection","text":"This helps to return the intersection results of given sets #Set Intersection month_list_old = {\"Jan\", \"Feb\", \"Mar\"} month_list_new = {\"Jan\", \"Feb\", \"Apr\"} print(\"The intersection result of given two sets are\") print(month_list_old & month_list_new) Output The intersection result of given two sets are {'Jan', 'Feb'}","title":"Set Intersection"},{"location":"python/set_functions/#set-difference","text":"This helps to return the set difference of one set from another set #Set Difference month_list_old = {\"Jan\", \"Feb\", \"Mar\"} month_list_new = {\"Jan\", \"Feb\", \"Apr\"} print(\"The set difference of one set from another set is\") print(month_list_old - month_list_new) Output The set difference of one set from another set is {'Mar'}","title":"Set Difference"},{"location":"python/set_functions/#set-symmetric-difference","text":"This return the element which is available in any one of the given set. If it is available in both set, it won't return as result #Set Symmetric Difference month_list_old = {\"Jan\", \"Feb\", \"Mar\"} month_list_new = {\"Jan\", \"Feb\", \"Apr\"} print(\"The set symmetric difference is :\") print(month_list_old ^ month_list_new) Output The set symmetric difference is : {'Mar', 'Apr'}","title":"Set symmetric Difference"},{"location":"python/set_functions/#clear-method","text":"This method removes all the element in given set and make it as empty set #Clear Set Method month_list = {\"Jan\", \"Feb\", \"Mar\"} month_list.clear() print(\"The clear set result is :\") print(month_list) Output The clear set result is : set()","title":"Clear Method"},{"location":"python/set_functions/#pop-method","text":"This method helps the remove the random value from the given set #POP Method month_list = {\"Jan\", \"Feb\", \"Mar\"} month_list.pop() print(\"The POP method removes random value :\") print(month_list) Output The POP method removes random value : {'Jan', 'Feb'} Note: Since POP method removes value randomly from given set, you may end up in different output","title":"Pop Method"},{"location":"python/set_functions/#isdisjoint-method","text":"This method returns true if both sets not have any common element #Isdisjoint Method month_list_old = {\"Jan\", \"Feb\", \"Mar\"} month_list_new = {\"Apr\", \"May\", \"Jun\"} print(\"Isdisjoint method result is :\") print(month_list_old.isdisjoint(month_list_new)) Output Isdisjoint method result is : True","title":"Isdisjoint Method"},{"location":"python/set_functions/#issubset-method","text":"This method returns true if all element of given set is present in the another set #Issubset Method month_list_old = {\"Jan\", \"Feb\", \"Mar\"} month_list_new = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"} print(\"Issubset method result is :\") print(month_list_old.issubset(month_list_new)) Output Issubset method result is : True","title":"Issubset Method"},{"location":"python/set_functions/#issuperset-method","text":"This method returns true if the given set have all the element of another set #Issuperset Method month_list_old = {\"Jan\", \"Feb\", \"Mar\"} month_list_new = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"} #Return False - only 3 elements are present, remaining items missed print(month_list_old.issuperset(month_list_new)) #Return True - all items are present in month_list_new print(month_list_new.issuperset(month_list_old)) Output False True","title":"Issuperset Method"},{"location":"python/special_parameters/","text":"Normally, we can pass the arguments to function either by position and Keyword. But we can also restrict the user with optional (/ and *) symbols which decides how the argument should be passed to function Function Definition As per python documentation, please find below the function definition def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2): ----------- ---------- ---------- | | | | Positional or keyword | | - Keyword only -- Positional only Types of Special Parameters positional-only positional-or-keyword keyword-only Positional Only Below function indicates that it must call with first two parameters are positional and last two parameter are either keyword or positional #Positional Only def sum(num1, num2, /, num3, num4): result = num1 + num2 + num3 + num4 print(result) #Four positional sum(10, 20, 30, 40) #Three Positional and One Keyword sum(10, 20, 30, num4=40) #Two Positional and Two Keyword sum(10, 20, num3=30, num4=40) Output 100 100 100 If we call function with more than two keywords arguments raises exception #Positional Only def sum(num1, num2, /, num3, num4): result = num1 + num2 + num3 + num4 print(result) #One Positional and Three Keyword - Raises Exception sum(10, num2=20, num3=30, num4=40) Output Traceback (most recent call last): File \"<string>\", line 7, in <module> TypeError: sum() got some positional-only arguments passed as keyword arguments: 'num2' Positional or Keyword Below function indicates we can pass all arguments either positional-or-keyword #Positional or Keyword def sum(num1, num2, num3, num4): result = num1 + num2 + num3 + num4 print(result) #Four positional sum(10, 20, 30, 40) #Three Positional and One Keyword sum(10, 20, 30, num4=40) #Two Positional and Two Keyword sum(10, 20, num3=30, num4=40) #One Positional and Three Keyword sum(10, num2=20, num3=30, num4=40) #Four Keyword sum(num1=10, num2=20, num3=30, num4=40) Output 100 100 100 100 100 Keyword Only Below function indicates that it must call with first two arguments as positional and last two arguments as keyword #Positional or Keyword def sum(num1, num2, *, num3, num4): result = num1 + num2 + num3 + num4 print(result) #Two Positional and Two Keyword sum(10, 20, num3=30, num4=40) #One Positional and Three Keyword sum(10, num2=20, num3=30, num4=40) #Four Keyword sum(num1=10, num2=20, num3=30, num4=40) Output 100 100 100 If we call function with more than two positional arguments raises exception #Positional Only def sum(num1, num2, /, num3, num4): result = num1 + num2 + num3 + num4 print(result) #Four positional sum(10, 20, 30, 40) #Three Positional and One Keyword sum(10, 20, 30, num4=40) #Two Positional and Two Keyword sum(10, 20, num3=30, num4=40) Output Traceback (most recent call last): File \"<string>\", line 7, in <module> TypeError: sum() takes 2 positional arguments but 4 were given","title":"Special Parameters"},{"location":"python/special_parameters/#function-definition","text":"As per python documentation, please find below the function definition def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2): ----------- ---------- ---------- | | | | Positional or keyword | | - Keyword only -- Positional only","title":"Function Definition"},{"location":"python/special_parameters/#types-of-special-parameters","text":"positional-only positional-or-keyword keyword-only","title":"Types of Special Parameters"},{"location":"python/special_parameters/#positional-only","text":"Below function indicates that it must call with first two parameters are positional and last two parameter are either keyword or positional #Positional Only def sum(num1, num2, /, num3, num4): result = num1 + num2 + num3 + num4 print(result) #Four positional sum(10, 20, 30, 40) #Three Positional and One Keyword sum(10, 20, 30, num4=40) #Two Positional and Two Keyword sum(10, 20, num3=30, num4=40) Output 100 100 100 If we call function with more than two keywords arguments raises exception #Positional Only def sum(num1, num2, /, num3, num4): result = num1 + num2 + num3 + num4 print(result) #One Positional and Three Keyword - Raises Exception sum(10, num2=20, num3=30, num4=40) Output Traceback (most recent call last): File \"<string>\", line 7, in <module> TypeError: sum() got some positional-only arguments passed as keyword arguments: 'num2'","title":"Positional Only"},{"location":"python/special_parameters/#positional-or-keyword","text":"Below function indicates we can pass all arguments either positional-or-keyword #Positional or Keyword def sum(num1, num2, num3, num4): result = num1 + num2 + num3 + num4 print(result) #Four positional sum(10, 20, 30, 40) #Three Positional and One Keyword sum(10, 20, 30, num4=40) #Two Positional and Two Keyword sum(10, 20, num3=30, num4=40) #One Positional and Three Keyword sum(10, num2=20, num3=30, num4=40) #Four Keyword sum(num1=10, num2=20, num3=30, num4=40) Output 100 100 100 100 100","title":"Positional or Keyword"},{"location":"python/special_parameters/#keyword-only","text":"Below function indicates that it must call with first two arguments as positional and last two arguments as keyword #Positional or Keyword def sum(num1, num2, *, num3, num4): result = num1 + num2 + num3 + num4 print(result) #Two Positional and Two Keyword sum(10, 20, num3=30, num4=40) #One Positional and Three Keyword sum(10, num2=20, num3=30, num4=40) #Four Keyword sum(num1=10, num2=20, num3=30, num4=40) Output 100 100 100 If we call function with more than two positional arguments raises exception #Positional Only def sum(num1, num2, /, num3, num4): result = num1 + num2 + num3 + num4 print(result) #Four positional sum(10, 20, 30, 40) #Three Positional and One Keyword sum(10, 20, 30, num4=40) #Two Positional and Two Keyword sum(10, 20, num3=30, num4=40) Output Traceback (most recent call last): File \"<string>\", line 7, in <module> TypeError: sum() takes 2 positional arguments but 4 were given","title":"Keyword Only"},{"location":"python/string_functions/","text":"Various built-in functions are available in Python which helps to perform multiple operations on string. Below are the top must know string methods in python Built-In Functions upper() - converts the given string to uppercase lower() - converts the given string to lowercase len() - Returns the length of the given string Below simple program shows the use case of all functions #String Functions school_name = \"Rathna Schools\" #Upper Method print(school_name.upper()) #Lower Method print(school_name.lower()) #Length Function print(\"Length of given string is : {}\".format(len(school_name))) Output RATHNA SCHOOLS rathna schools Length of given string is : 14 Boolean Methods isupper() - returns true if all the characters in given string are uppercase islower() - returns true if all the characters in given string are lowercase isalpha() - returns true if all the characters in given string are alphabets isnumeric() - returns true if all the characters in given string are number isalnum() - returns true if all the characters in given string are alphanumeric Below simple program shows the use case of all boolean methods #Boolean Methods #Isupper method school_name = \"RATHNA SCHOOLS\" print(school_name.isupper()) #Islower method school_name = \"rathna schools\" print(school_name.islower()) #Isalpha method school_name = \"RathnaSchools\" print(school_name.isalpha()) #Isnumeric method register_number = \"12345\" print(register_number.isnumeric()) #Isalnum method user_name = \"RathnaSchools12345\" print(register_number.isalnum()) Output True True True True True Reusable Methods split() - helps to split the given string with given character join() - helps to join the given character with existing each character of given string replace() - helps to replace the old characters of given string with new character find() - returns the first occurrence of the specified value, if not available -1 will returns Below simple program shows the use case of all reusable methods #Reusable Methods #Split Method school_name = \"RATHNA SCHOOLS\" splitted_list = school_name.split() print(splitted_list) #Join Function joined_school_name = \" \".join(splitted_list) print(joined_school_name) #Replace Method replaced_school_name = joined_school_name.replace(\" \",\"|\") print(replaced_school_name) #Find Method print(school_name.find(\"R\")) #First instance considers incase of multiple occurrence print(school_name.find(\"S\")) #Returns -1 when no occurrence found print(school_name.find(\"z\")) Output ['RATHNA', 'SCHOOLS'] RATHNA SCHOOLS RATHNA|SCHOOLS 0 7 -1","title":"String Functions"},{"location":"python/string_functions/#built-in-functions","text":"upper() - converts the given string to uppercase lower() - converts the given string to lowercase len() - Returns the length of the given string Below simple program shows the use case of all functions #String Functions school_name = \"Rathna Schools\" #Upper Method print(school_name.upper()) #Lower Method print(school_name.lower()) #Length Function print(\"Length of given string is : {}\".format(len(school_name))) Output RATHNA SCHOOLS rathna schools Length of given string is : 14","title":"Built-In Functions"},{"location":"python/string_functions/#boolean-methods","text":"isupper() - returns true if all the characters in given string are uppercase islower() - returns true if all the characters in given string are lowercase isalpha() - returns true if all the characters in given string are alphabets isnumeric() - returns true if all the characters in given string are number isalnum() - returns true if all the characters in given string are alphanumeric Below simple program shows the use case of all boolean methods #Boolean Methods #Isupper method school_name = \"RATHNA SCHOOLS\" print(school_name.isupper()) #Islower method school_name = \"rathna schools\" print(school_name.islower()) #Isalpha method school_name = \"RathnaSchools\" print(school_name.isalpha()) #Isnumeric method register_number = \"12345\" print(register_number.isnumeric()) #Isalnum method user_name = \"RathnaSchools12345\" print(register_number.isalnum()) Output True True True True True","title":"Boolean Methods"},{"location":"python/string_functions/#reusable-methods","text":"split() - helps to split the given string with given character join() - helps to join the given character with existing each character of given string replace() - helps to replace the old characters of given string with new character find() - returns the first occurrence of the specified value, if not available -1 will returns Below simple program shows the use case of all reusable methods #Reusable Methods #Split Method school_name = \"RATHNA SCHOOLS\" splitted_list = school_name.split() print(splitted_list) #Join Function joined_school_name = \" \".join(splitted_list) print(joined_school_name) #Replace Method replaced_school_name = joined_school_name.replace(\" \",\"|\") print(replaced_school_name) #Find Method print(school_name.find(\"R\")) #First instance considers incase of multiple occurrence print(school_name.find(\"S\")) #Returns -1 when no occurrence found print(school_name.find(\"z\")) Output ['RATHNA', 'SCHOOLS'] RATHNA SCHOOLS RATHNA|SCHOOLS 0 7 -1","title":"Reusable Methods"},{"location":"python/tuple_functions/","text":"Various built-in functions are available in Python which helps to perform multiple operations on tuple. Below are the top must know tuple methods in python Count Method This function helps to returns the occurrence count of specified object in given tuple #Count Function mark_list = (10, 20, 30, 10, 50, 60, 10, 60) print(\"The count of 10 in the tuple is : {}\".format(mark_list.count(10))) Output The count of 10 in the tuple is : 3 Index Method This function returns the index of first occurrence for the given value #Index Method mark_list = (10, 20, 30, 10, 50, 60, 10, 60) #Returns the index of first occurrence print(\"The index of 60 is : {}\".format(mark_list.index(60))) Output The index of 60 is : 5 Max Function This function returns the maximum value of the given tuple #Max Function mark_list = (10, 20, 30, 10, 50, 60, 10, 60) #Returns the maximum element in the given list print(\"The maximum element in the given tuple is : {}\".format(max(mark_list))) Output The maximum element in the given list is : 60 Min Function This function returns the minimum value of given list #Min Function mark_list = (10, 20, 30, 10, 50, 60, 10, 60) #Returns the minimum element in the given list print(\"The minimum element in the given tuple is : {}\".format(min(mark_list))) Output The minimum element in the given tuple is : 10 Sum Function This function returns the summation of all the values in the given tuple #Sum Function month_list = (10, 20, 30, 40, 50) print(\"The sum of tuple is : {}\".format(sum(month_list))) Output The sum of tuple is : 150 Length Function This function returns the total length of given list #length Function mark_list = (10, 20, 30, 10, 50, 60, 10, 60) print(\"The length of tuple is : {}\".format(len(mark_list))) Output The length of tuple is : 8 Sort Function Sort Method returns the sorting order of the given tuple #Sort Function mark_list = (10, 20, 30, 10, 50, 60, 10, 60) print(\"Tuple before sorting : \") print(mark_list) print(\"Tuple after sorting - ascending : \") print(sorted(mark_list)) print(\"Tuple after sorting - descending : \") print(sorted(mark_list, reverse=True)) Output Tuple before sorting : (10, 20, 30, 10, 50, 60, 10, 60) Tuple after sorting - ascending : [10, 10, 10, 20, 30, 50, 60, 60] Tuple after sorting - descending : [60, 60, 50, 30, 20, 10, 10, 10]","title":"Tuple Functions"},{"location":"python/tuple_functions/#count-method","text":"This function helps to returns the occurrence count of specified object in given tuple #Count Function mark_list = (10, 20, 30, 10, 50, 60, 10, 60) print(\"The count of 10 in the tuple is : {}\".format(mark_list.count(10))) Output The count of 10 in the tuple is : 3","title":"Count Method"},{"location":"python/tuple_functions/#index-method","text":"This function returns the index of first occurrence for the given value #Index Method mark_list = (10, 20, 30, 10, 50, 60, 10, 60) #Returns the index of first occurrence print(\"The index of 60 is : {}\".format(mark_list.index(60))) Output The index of 60 is : 5","title":"Index Method"},{"location":"python/tuple_functions/#max-function","text":"This function returns the maximum value of the given tuple #Max Function mark_list = (10, 20, 30, 10, 50, 60, 10, 60) #Returns the maximum element in the given list print(\"The maximum element in the given tuple is : {}\".format(max(mark_list))) Output The maximum element in the given list is : 60","title":"Max Function"},{"location":"python/tuple_functions/#min-function","text":"This function returns the minimum value of given list #Min Function mark_list = (10, 20, 30, 10, 50, 60, 10, 60) #Returns the minimum element in the given list print(\"The minimum element in the given tuple is : {}\".format(min(mark_list))) Output The minimum element in the given tuple is : 10","title":"Min Function"},{"location":"python/tuple_functions/#sum-function","text":"This function returns the summation of all the values in the given tuple #Sum Function month_list = (10, 20, 30, 40, 50) print(\"The sum of tuple is : {}\".format(sum(month_list))) Output The sum of tuple is : 150","title":"Sum Function"},{"location":"python/tuple_functions/#length-function","text":"This function returns the total length of given list #length Function mark_list = (10, 20, 30, 10, 50, 60, 10, 60) print(\"The length of tuple is : {}\".format(len(mark_list))) Output The length of tuple is : 8","title":"Length Function"},{"location":"python/tuple_functions/#sort-function","text":"Sort Method returns the sorting order of the given tuple #Sort Function mark_list = (10, 20, 30, 10, 50, 60, 10, 60) print(\"Tuple before sorting : \") print(mark_list) print(\"Tuple after sorting - ascending : \") print(sorted(mark_list)) print(\"Tuple after sorting - descending : \") print(sorted(mark_list, reverse=True)) Output Tuple before sorting : (10, 20, 30, 10, 50, 60, 10, 60) Tuple after sorting - ascending : [10, 10, 10, 20, 30, 50, 60, 60] Tuple after sorting - descending : [60, 60, 50, 30, 20, 10, 10, 10]","title":"Sort Function"},{"location":"python/user_defined_function/","text":"Functions are organized reusable code block, which can be called whenever we required in our program. It helps to chunk our large program into smaller code blocks and provides greater re-usability User defined function These functions creates by user for perform customized task. Below are the major types of ways, we can create a user defined functions in python Function Creation without Arguments def keyword helps to create functions in python #Function definition def add(): value1 = 10 value2 = 30 sum = value1 + value2 print(sum) #Function Calling add() #Function can call how many times we required add() Output 40 40 Function Creation with Arguments Arguments helps to pass the values to the functions dynamically #Function definition def add(num1, num2): value1 = num1 value2 = num2 sum = value1 + value2 print(sum) #Function Calling add(10, 20) #Function calling with different parameter values add(50, 100) Output 30 150 Function Creation with return values Return keywords helps to return the required value from a function #Function definition def add(num1, num2): value1 = num1 value2 = num2 sum = value1 + value2 return sum #Function Calling result = add(10, 20) print(result) #Function calling with different parameter values result = add(50, 100) print(result) Output 30 150","title":"User Defined Functions"},{"location":"python/user_defined_function/#user-defined-function","text":"These functions creates by user for perform customized task. Below are the major types of ways, we can create a user defined functions in python","title":"User defined function"},{"location":"python/user_defined_function/#function-creation-without-arguments","text":"def keyword helps to create functions in python #Function definition def add(): value1 = 10 value2 = 30 sum = value1 + value2 print(sum) #Function Calling add() #Function can call how many times we required add() Output 40 40","title":"Function Creation without Arguments"},{"location":"python/user_defined_function/#function-creation-with-arguments","text":"Arguments helps to pass the values to the functions dynamically #Function definition def add(num1, num2): value1 = num1 value2 = num2 sum = value1 + value2 print(sum) #Function Calling add(10, 20) #Function calling with different parameter values add(50, 100) Output 30 150","title":"Function Creation with Arguments"},{"location":"python/user_defined_function/#function-creation-with-return-values","text":"Return keywords helps to return the required value from a function #Function definition def add(num1, num2): value1 = num1 value2 = num2 sum = value1 + value2 return sum #Function Calling result = add(10, 20) print(result) #Function calling with different parameter values result = add(50, 100) print(result) Output 30 150","title":"Function Creation with return values"},{"location":"python/while_loop/","text":"Looping statements are used to execute the same instruction again and again until the conditions get satisfied While Loop While loop not require any iterable, it will execute a block of code repeatedly until the condition get fails #While Loop count = 0 #Looping for 5 times while count<5: print(count) #Increment is mandatory here, otherwise results in infinite loop count=count+1 Output 0 1 2 3 4 While Break Even though the condition is true still we can stop the loop with the help of break statement #While Break Loop count = 0 #Looping for 3 times while count<5: print(count) count=count+1 #break the loop when count is 3 if count==3: break Output 0 1 2 While Continue Even though the condition is true still we can stop the specific iteration using continue statement #While Continue count = 0 #Looping for 4 times while count<5: count=count+1 #skip the print when count is 3 if count==3: continue print(count) Output 1 2 4 5 While Else One of the unique feature in python is while loop with else clause #While Else count = 0 #Looping for 4 times while count<5: count=count+1 print(count) else: print(\"Loop broken - count is higher than 5 now\") Output 1 2 3 4 5 Loop broken - count is higher than 5 now While Break Else One of the unique feature in python is while loop with else clause #While Break Else count = 0 #Looping for 4 times while count<5: count=count+1 if count==3: break print(count) #Else statement won't execute since loop breaks else: print(\"Loop broken - count is higher than 5 now\") Output 1 2 While Continue Else Else statement execute for continue since it will only skip only the particular execution #While Continue Else count = 0 while count<5: count=count+1 if count==3: continue print(count) #Else statement execute since loop continues else: print(\"Loop broken - count is higher than 5 now\") Output 1 2 4 5 Loop broken - count is higher than 5 now","title":"While Loop Statements"},{"location":"python/while_loop/#while-loop","text":"While loop not require any iterable, it will execute a block of code repeatedly until the condition get fails #While Loop count = 0 #Looping for 5 times while count<5: print(count) #Increment is mandatory here, otherwise results in infinite loop count=count+1 Output 0 1 2 3 4","title":"While Loop"},{"location":"python/while_loop/#while-break","text":"Even though the condition is true still we can stop the loop with the help of break statement #While Break Loop count = 0 #Looping for 3 times while count<5: print(count) count=count+1 #break the loop when count is 3 if count==3: break Output 0 1 2","title":"While Break"},{"location":"python/while_loop/#while-continue","text":"Even though the condition is true still we can stop the specific iteration using continue statement #While Continue count = 0 #Looping for 4 times while count<5: count=count+1 #skip the print when count is 3 if count==3: continue print(count) Output 1 2 4 5","title":"While Continue"},{"location":"python/while_loop/#while-else","text":"One of the unique feature in python is while loop with else clause #While Else count = 0 #Looping for 4 times while count<5: count=count+1 print(count) else: print(\"Loop broken - count is higher than 5 now\") Output 1 2 3 4 5 Loop broken - count is higher than 5 now","title":"While Else"},{"location":"python/while_loop/#while-break-else","text":"One of the unique feature in python is while loop with else clause #While Break Else count = 0 #Looping for 4 times while count<5: count=count+1 if count==3: break print(count) #Else statement won't execute since loop breaks else: print(\"Loop broken - count is higher than 5 now\") Output 1 2","title":"While Break Else"},{"location":"python/while_loop/#while-continue-else","text":"Else statement execute for continue since it will only skip only the particular execution #While Continue Else count = 0 while count<5: count=count+1 if count==3: continue print(count) #Else statement execute since loop continues else: print(\"Loop broken - count is higher than 5 now\") Output 1 2 4 5 Loop broken - count is higher than 5 now","title":"While Continue Else"}]}